html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>å®æ—¶èŠå¤©å®¤</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
;(function(){
  /* 1. passive-patch ä¿æŒåŸæ · */
  const PASSIVE_EVENTS = new Set([
      'scroll',
      'wheel',
      'mousewheel',  // 
      'touchstart',
      'touchmove',
      'touchenter',
      'touchend',
      'touchleave',
      'touchcancel'
    ]);
  const _orig = EventTarget.prototype.addEventListener;
  EventTarget.prototype.addEventListener = function(type, fn, opts){
    if (PASSIVE_EVENTS.has(type)){
      if (opts===undefined) opts={passive:true};
      else if (typeof opts==='boolean') opts={capture:opts, passive:true};
      else if (typeof opts==='object' && opts.passive===undefined) opts.passive=true;
    }
    return _orig.call(this, type, fn, opts);
  };
  /* 2. ç­‰ DOM å®Œå…¨å°±ç»ªåå†è§£é” AudioContext */
  document.addEventListener('DOMContentLoaded', ()=>{
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    function unlockAudioContext(e){
      if (e.type==='touchend') e.preventDefault();
      const ac = new AudioCtx();
      if (ac.state==='suspended') ac.resume();
      new Audio("data:audio/mp3;base64,SUQz...").play().catch(()=>{    }); // è¿™é‡Œçš„éŸ³é¢‘æ•°æ®åº”è¯¥æ˜¯ä¸€ä¸ªå®Œæ•´çš„Base64ç¼–ç MP3æ•°æ®
      document.body.removeEventListener('click', unlockAudioContext);
      document.body.removeEventListener('touchend', unlockAudioContext);
    }
    document.body.addEventListener('click', unlockAudioContext, { once: true });
    document.body.addEventListener('touchend', unlockAudioContext, { once: true, passive: false });
  });
})();
</script>
    <style>
        /* --- THEME VARIABLES --- */
        :root {
          /* æµ…è‰²é»˜è®¤å€¼ */
          --bg: #f8f9fa;
          --bg-panel: #ffffff;
          --text: #2c3e50;
          --text-sub: #6c757d;
          --border: #e9ecef;
          --accent: #667eea;
          --accent2: #764ba2;
          --shadow: rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
          --bg: #111827;
          --bg-panel: #1f2937;
          --text: #f9fafb;
          --text-sub: #9ca3af;
          --border: #374151;
          --accent: #818cf8;
          --accent2: #a78bfa;
          --shadow: rgba(0,0,0,0.4);
        }

        /* --- BASE STYLES --- */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent2) 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            overscroll-behavior: none; /* é˜²æ­¢æ•´é¡µæ©¡çš®ç­‹æ•ˆæœ */
        }
        
        .chat-container {
            width: 90%;
            max-width: 800px;
            height: 100%;
            background: var(--bg-panel);
            border-radius: 12px;
            box-shadow: 0 10px 30px var(--shadow);
            display: flex;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        .sidebar {
            width: 280px;
            background: linear-gradient(180deg, #2c3e50 0%, #3498db 100%);
            color: white; /* ä¾§è¾¹æ æ–‡å­—å§‹ç»ˆä¸ºç™½è‰²ä»¥ç¡®ä¿å¯è¯»æ€§ */
            padding: 0;
            border-right: none;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            box-shadow: 2px 0 10px var(--shadow);
            transition: background 0.3s ease;
        }
        [data-theme="dark"] .sidebar {
            background: linear-gradient(180deg, #1f2937 0%, #374151 100%);
        }
        
        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.1);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .sidebar h2 {
            margin: 0;
            color: white;
            font-size: 1.2em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .online-indicator {
            width: 8px;
            height: 8px;
            color: white;
            background: #2ecc71;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .user-list-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .user-list-title {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.9);
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .user-row {
            display: flex;
            align-items: flex-start;
            margin-bottom: 16px;
            gap: 16px;
        }
        
        .user-names {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: flex-start;
        }
        
        .user-item {
            padding: 6px 10px;
            font-size: 0.8em;
            background: rgba(255,255,255,0.15);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            color: white; /* Ensure text is visible */
        }
        
        .user-item::before { content: 'ğŸ‘¤'; font-size: 10px; }
        .user-item:hover { background: rgba(255,255,255,0.25); transform: scale(1.05); box-shadow: 0 2px 8px var(--shadow); }
        .user-info { flex: 1; display: flex; flex-direction: column; gap: 8px; font-size: 0.75em; }
        .info-row { display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; background: rgba(255,255,255,0.08); border-radius: 8px; transition: all 0.3s ease; border: 1px solid rgba(255,255,255,0.05); }
        .info-row:hover { background: rgba(255,255,255,0.15); box-shadow: 0 2px 6px var(--shadow); }
        .info-label { color: rgba(255,255,255,0.8); font-weight: 500; }
        .info-value { color: white; font-weight: 600; text-align: right; }
        .online-count { color: #2ecc71; font-size: 1.1em; }
        .room-name-sidebar { color: #f39c12; font-size: 0.9em; }

        .user-stats-container {
            padding: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: auto; /* Push to bottom */
            max-height: 50vh; /* è®¾ç½®ä¸€ä¸ªæœ€å¤§é«˜åº¦ï¼Œä¾‹å¦‚ 250px */
            overflow-y: auto;  /* å½“å†…å®¹è¶…å‡ºæœ€å¤§é«˜åº¦æ—¶ï¼Œå‚ç›´æ–¹å‘æ˜¾ç¤ºæ»šåŠ¨æ¡ */
        }
        .user-stats-item {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            color: white;
            font-size: 0.85em;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .user-stats-item:last-child { margin-bottom: 0; }
        .user-stats-item strong { color: #f39c12; }
        .user-stats-item .stat-label { opacity: 0.8; font-size: 0.9em; }
        .user-stats-item .stat-value { font-weight: 600; }
        .user-stats-item .stat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .user-stats-item .stat-row:last-child { margin-bottom: 0; }
        .user-stats-item .online-status { color: #2ecc71; font-weight: 600; }
        .user-stats-item .offline-status { color: #e74c3c; font-weight: 600; }
        
        /* --- MAIN CHAT AREA --- */
        .main-chat { flex: 1; display: flex; flex-direction: column; min-width: 0; height: 100%; }
        .chat-header { padding: 12px 25px; background: linear-gradient(135deg, var(--accent) 0%, var(--accent2) 100%); color: white; display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; box-shadow: 0 2px 15px var(--shadow); position: relative; }
        .sidebar-toggle { display: none; align-items: center; justify-content: center; width: 36px; height: 36px; background: rgba(255, 255, 255, 0.2); border: none; border-radius: 8px; font-size: 16px; color: white; cursor: pointer; transition: all 0.3s ease; flex-shrink: 0; }
        .sidebar-toggle:hover { background: rgba(255, 255, 255, 0.3); }
        .chat-info { display: flex; align-items: center; gap: 12px; flex: 0 0 auto; }
        .room-icon { width: 32px; height: 32px; background: rgba(255, 255, 255, 0 ); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0; }
        .chat-details { display: flex; flex-direction: column; min-width: 0; }
        .room-name { font-size: 1.1em; font-weight: 700; margin: 0; color: white; text-shadow: 0 1px 3px var(--shadow); }
        .user-status { font-size: 0.8em; opacity: 0.9; margin: 2px 0 0 0; display: flex; align-items: center; gap: 6px; }
        #username-display {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 3px;
            transition: color 0.3s;
        }
        #username-display:hover {
            color: #f39c12;
        }
        .connection-dot { width: 6px; height: 6px; background: #2ecc71; border-radius: 50%; animation: pulse 2s infinite; }
        .connection-dot.disconnected { background: #e74c3c; animation: none; }
        .online-users-display { cursor: pointer; user-select: none; font-size: 0.8em; font-weight: 500; color: rgba(255, 255, 255, 0.9); background: rgba(255,255,255,0.15); padding: 6px 10px; border-radius: 12px; backdrop-filter: blur(10px); flex-shrink: 0; white-space: nowrap; transition: all 0.3s ease; }
        .online-users-display:hover { background: rgba(255,255,255,0.25); }
        .users-menu { display: none; position: absolute; top: 100%; right: 25px; background: var(--bg-panel); border: 1px solid var(--border); box-shadow: 0 4px 12px var(--shadow); border-radius: 8px; max-height: 200px; overflow-y: auto; z-index: 200; margin-top: 8px; min-width: 160px; }
        .users-menu.show { display: block; }
        .users-menu ul { list-style: none; margin: 0; padding: 8px 0; }
        .users-menu li { padding: 8px 12px; font-size: 0.9em; color: var(--text); white-space: nowrap; display: flex; align-items: center; gap: 6px; }
        .users-menu li::before { content: 'ğŸ‘¤'; font-size: 12px; }
        .users-menu li:hover { background: var(--bg); }

        /* --- CHAT WINDOW --- */
        #chat-window { 
            flex: 1; 
            padding: 20px 25px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px)); 
            overflow-y: auto; 
            min-height: 0; 
            background: var(--bg); 
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch; /* å…³é”®: ä½¿iOSè®¾å¤‡ä¸Šçš„æ»šåŠ¨æ›´æµç•… */
            overscroll-behavior: contain; /* ç¡®ä¿æ»šåŠ¨è¡Œä¸ºè¢«åŒ…å« */
            touch-action: pan-y; /* æ˜ç¡®å¯ç”¨å‚ç›´å¹³ç§» */
            /* ç§»é™¤äº†è™šæ‹Ÿæ»šåŠ¨ç›¸å…³çš„ flex å¸ƒå±€å’Œ order å±æ€§ */
        }
        #chat-window::-webkit-scrollbar { width: 4px; }
        #chat-window::-webkit-scrollbar-track { background: transparent; }
        #chat-window::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
        #chat-window::-webkit-scrollbar-thumb:hover { background: var(--text-sub); }
        /* è™šæ‹Ÿæ»šåŠ¨ç›¸å…³çš„å¡«å……å…ƒç´ æ ·å¼ä¸å†éœ€è¦ */


        /* --- MESSAGE STYLES --- */
        .message { margin-bottom: 16px; display: flex; flex-direction: column; animation: fadeInUp 0.3s ease; }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
        .message .info { margin-bottom: 5px; }
        .message .info .username { font-size: 0.85em; font-weight: 700; color: var(--text); }
        .message .info .timestamp { font-size: 0.65em; color: var(--text-sub); }
        .message .text { padding: 10px 10px; background: var(--bg-panel); border-radius: 16px; max-width: 75%; line-height: 1.4; word-wrap: break-word; box-shadow: 0 1px 6px var(--shadow); border: 1px solid var(--border); position: relative; color: var(--text); }
        .message.self { align-items: flex-end; }
        .message.self .text { background: linear-gradient(135deg, var(--accent) 0%, var(--accent2) 100%); color: white; border: none; }
        .message.self .info { text-align: right; }

        /* --- MARKDOWN STYLES --- */
        .message .text { line-height: 1.6; }
        .message .text h1, .message .text h2, .message .text h3 { margin-top: 0.5em; margin-bottom: 0.5em; border-bottom: 1px solid var(--border); padding-bottom: 0.3em; }
        .message.self .text h1, .message.self .text h2, .message.self .text h3 { border-bottom-color: rgba(255, 255, 255, 0.3); }
        .message .text p { margin-top: 0; margin-bottom: 0; }
        .message .text ul, .message .text ol { padding-left: 1.5em; margin-bottom: 1em; }
        .message .text li { margin-bottom: 0.25em; }
        .message .text pre { background-color: #2d2d2d; color: #f8f8f2; padding: 1em; border-radius: 8px; overflow-x: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.9em; margin: 1em 0; }
        [data-theme="dark"] .message .text pre { background-color: #111827; }
        .message.self .text pre { background-color: rgba(0, 0, 0, 0.2); }
        .message .text code { background-color: rgba(0,0,0,0.05); padding: 0.2em 0.4em; border-radius: 4px; font-family: 'Courier New', Courier, monospace; color: var(--text); }
        [data-theme="dark"] .message .text code { background-color: #374151; }
        .message.self .text code { background-color: rgba(255, 255, 255, 0.2); }
        .message .text pre > code { background-color: transparent; padding: 0; }
        .message .text blockquote { border-left: 4px solid var(--border); padding-left: 1em; margin: 1em 0; color: var(--text-sub); }
        .message.self .text blockquote { border-left-color: rgba(255, 255, 255, 0.5); color: rgba(255, 255, 255, 0.8); }
        .message .text table { border-collapse: collapse; width: 100%; margin: 1em 0; }
        .message .text th, .message .text td { border: 1px solid var(--border); padding: 0.5em; }
        .message.self .text th, .message.self .text td { border-color: rgba(255, 255, 255, 0.3); }
        .message .text th { background-color: var(--bg); }
        .message.self .text th { background-color: rgba(0, 0, 0, 0.1); }
        .message .text a { color: var(--accent); text-decoration: none; }
        .message .text a:hover { text-decoration: underline; }
        .message.self .text a { color: #a0c8ff; }

        /* --- MEDIA MESSAGE STYLES --- */
        .message-image { padding: 4px; background: var(--bg-panel); border-radius: 16px; max-width: 300px; box-shadow: 0 1px 6px var(--shadow); border: 1px solid var(--border); overflow: hidden; cursor: pointer; transition: all 0.3s ease; position: relative; }
        .message-image:hover { transform: scale(1.02); box-shadow: 0 4px 12px var(--shadow); }
        .message-image img { width: 100%; height: auto; border-radius: 12px; display: block; }
        .message.self .message-image { background: rgba(255,255,255,0.1); border: none; }
        .message-audio { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: var(--bg); border-radius: 16px; border: 1px solid var(--border); }
        .message.self .message-audio { background: var(--accent); border: none; }
        .message-audio audio { outline: none; }
        
        /* --- IMAGE MODAL & PREVIEW --- */
        .image-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; justify-content: center; align-items: center; animation: fadeIn 0.3s ease; }
        .image-modal.show { display: flex; }
        .image-modal img { max-width: 90%; max-height: 90%; border-radius: 8px; box-shadow: 0 10px 30px var(--shadow); }
        .image-modal-close { position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.2); border: none; color: white; font-size: 24px; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; }
        .image-modal-close:hover { background: rgba(255,255,255,0.3); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- INPUT AREA --- */
        #message-form { position: sticky; bottom: env(safe-area-inset-bottom, 0); display: flex; padding: 8px 12px; gap: 6px; align-items: center; border-top: 1px solid var(--border); background: var(--bg-panel); box-shadow: 0 -2px 15px var(--shadow); z-index: 100; }
        .icon-btn {
            background: none;
            border: none;
            color: var(--text-sub);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
            width: 36px;
            height: 36px;
        }
        .icon-btn:hover {
            background: var(--bg);
            color: var(--accent);
        }
        .icon-btn.recording {
            animation: pulse 1.5s infinite;
            background: #e74c3c;
            color: white;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .voice-input-status {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent);
            color: white;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 0.95em;
            margin-bottom: 8px;
            box-shadow: 0 4px 15px var(--shadow);
            display: none;
            z-index: 1000;
            min-width: 200px;
            text-align: center;
            white-space: nowrap;
        }
        .voice-input-status.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }        .input-wrapper { flex: 1; position: relative; margin: 0 4px; }
        .clear-btn {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-sub);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
            z-index: 10;
        }
        .clear-btn:hover {
            background-color: var(--border);
            color: var(--text);
        }
        .clear-btn:active {
            transform: translateY(-50%) scale(0.9);
        }
        #message-input { width: 100%; padding: 12px 40px 12px 18px; border: 2px solid var(--border); border-radius: 22px; outline: none; font-size: 0.95em; font-family: inherit; resize: none; min-height: 20px; max-height: 100px; line-height: 1.4; transition: all 0.3s ease; box-sizing: border-box; background-color: var(--bg); color: var(--text); }
        #message-input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 15%, transparent); }
        #image-input { display: none; }
        .image-preview { position: absolute; bottom: 100%; left: 0; right: 0; background: var(--bg-panel); border: 2px solid var(--accent); border-radius: 12px; padding: 12px; margin-bottom: 8px; box-shadow: 0 4px 20px var(--shadow); display: none; }
        .image-preview.show { display: block; }
        .preview-content { display: flex; align-items: center; gap: 12px; }
        .preview-image { width: 60px; height: 60px; border-radius: 8px; object-fit: cover; border: 1px solid var(--border); }
        .preview-info { flex: 1; min-width: 0; }
        .preview-name { font-size: 0.9em; font-weight: 600; color: var(--text); margin-bottom: 4px; word-break: break-all; }
        .preview-size { font-size: 0.8em; color: var(--text-sub); }
        .preview-remove { background: #e74c3c; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; transition: all 0.3s ease; }
        .preview-remove:hover { background: #c0392b; }
        .uploading { opacity: 0.6; pointer-events: none; }
        .upload-progress { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: color-mix(in srgb, var(--accent) 90%, black); color: white; padding: 8px 12px; border-radius: 8px; font-size: 0.8em; font-weight: 500; }
        #send-button { padding: 0; border: none; background: linear-gradient(135deg, var(--accent) 0%, var(--accent2) 100%); color: white; border-radius: 50%; cursor: pointer; font-size: 18px; transition: all 0.3s ease; box-shadow: 0 3px 12px color-mix(in srgb, var(--accent) 30%, transparent); width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; }
        #send-button:hover { transform: translateY(-1px); box-shadow: 0 5px 15px color-mix(in srgb, var(--accent) 40%, transparent); }
        #send-button:active { transform: translateY(0); }
        #send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .mentions-suggestions {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            z-index: 200;
            box-shadow: 0 -4px 12px var(--shadow);
        }

        .mentions-suggestions .user-item {
            padding: 8px 12px;
            cursor: pointer;
            color: var(--text);
        }

        .mentions-suggestions .user-item:hover {
            background: var(--bg);
        }
        
        /* --- CONTEXT MENU & AI EXPLANATION STYLES --- */
        .context-menu { display: none; position: absolute; background-color: var(--bg-panel); border: 1px solid var(--border); border-radius: 5px; box-shadow: 0 2px 5px var(--shadow); z-index: 1000; }
        .context-menu ul { list-style: none; padding: 5px 0; margin: 0; }
        .context-menu ul li { padding: 8px 15px; cursor: pointer; color: var(--text); }
        .context-menu ul li:hover { background-color: var(--bg); }

        /* Call Controls */
        #call-controls-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1001;
        }
        .call-control-panel {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .hang-up-btn {
            background: #e74c3c;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
        }
        .user-menu-item-with-call {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .call-btn {
            background: #2ecc71;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            margin-left: 10px;
        }
        .unmute-notice {
            background: #f39c12;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
        }

        /* (å¯é€‰) ä¸ºAIèœå•é¡¹æ·»åŠ å›¾æ ‡ */
        .context-menu .ai-explain-option {
            display: flex;
            align-items: center;
            gap: 8px; /* å›¾æ ‡å’Œæ–‡å­—çš„é—´è· */
        }

        .context-menu .ai-explain-option::before {
            content: 'ğŸ‡¨ğŸ‡³'; /* AIå°æœºå™¨äººå›¾æ ‡ */
            font-size: 14px;
        }   
        .ai-explanation { position: relative; background-color: var(--bg); border: 1px solid var(--border); border-radius: 12px; padding: 12px 16px; margin-top: 8px; font-size: 0.85em; color: var(--text); line-height: 1.5; animation: fadeInUp 0.4s ease; box-shadow: 0 2px 5px var(--shadow); max-width: 75%; box-sizing: border-box; align-self: flex-start; }
        .message.self .ai-explanation { align-self: flex-end; }
        .ai-explanation::before { content: 'ğŸ¤– AI è§£é‡Š:'; font-weight: 600; color: var(--text-sub); display: block; margin-bottom: 6px; font-size: 0.9em; }
        .ai-explanation p { margin: 0; }
        .ai-explanation-close { background: none; border: none; color: var(--text-sub); font-size: 16px; cursor: pointer; width: 24px; height: 24px; line-height: 24px; text-align: center; border-radius: 50%; transition: all 0.2s ease; }
        .ai-explanation-close:hover { background-color: var(--border); color: var(--text); }
        .ai-explanation-copy { background: none; border: none; color: var(--text-sub); font-size: 16px; cursor: pointer; width: 24px; height: 24px; line-height: 24px; text-align: center; border-radius: 50%; transition: all 0.2s ease; margin-right: 5px; }
        .ai-explanation-copy:hover { background-color: var(--border); color: var(--text); }
        .ai-explanation-buttons { position: absolute; top: 6px; right: 6px; display: flex; gap: 5px; }
        
        .ai-explanation .markdown-content { font-size: 0.9em; line-height: 1.6; text-align: left; }
        .ai-explanation .markdown-content p { margin-bottom: 12px; }
        .ai-explanation .markdown-content p:last-child { margin-bottom: 0; }
        .ai-explanation .markdown-content h1, .ai-explanation .markdown-content h2, .ai-explanation .markdown-content h3 { margin-top: 16px; margin-bottom: 8px; border-bottom: 1px solid var(--border); padding-bottom: 4px; }
        .ai-explanation .markdown-content pre { background-color: #2d2d2d; color: #f8f8f2; padding: 12px; border-radius: 8px; overflow-x: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.85em; }
        [data-theme="dark"] .ai-explanation .markdown-content pre { background-color: #111827; }
        .ai-explanation .markdown-content code { background-color: var(--border); padding: 2px 5px; border-radius: 4px; font-family: 'Courier New', Courier, monospace; }
        .ai-explanation .markdown-content pre code { background-color: transparent; padding: 0; }
        .ai-explanation .markdown-content ul, .ai-explanation .markdown-content ol { padding-left: 20px; margin-top: 8px; margin-bottom: 12px; }
        .ai-explanation .markdown-content blockquote { border-left: 4px solid var(--border); padding-left: 12px; margin: 12px 0; color: var(--text-sub); background-color: color-mix(in srgb, var(--bg) 50%, transparent); }
        .ai-explanation .markdown-content a { color: var(--accent); text-decoration: none; }
        .ai-explanation .markdown-content a:hover { text-decoration: underline; }

        .loading-dots {
            display: inline-block;
            width: 1.5em;
            text-align: left;
        }
        .loading-dots::after {
            content: '.';
            animation: dots 1s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { color: rgba(0,0,0,0); text-shadow:
                .25em 0 0 rgba(0,0,0,0),
                .5em 0 0 rgba(0,0,0,0); }
            40% { color: black; text-shadow:
                .25em 0 0 rgba(0,0,0,0),
                .5em 0 0 rgba(0,0,0,0); }
            60% { text-shadow:
                .25em 0 0 black,
                .5em 0 0 rgba(0,0,0,0); }
            80%, 100% { text-shadow:
                .25em 0 0 black,
                .5em 0 0 black; }
        }

        /* --- RESPONSIVE --- */
        @media (max-width: 768px) {
            html, body { 
                height: 100%; /* ä½¿ç”¨å›ºå®šé«˜åº¦ */
                overflow: hidden; /* é˜²æ­¢æ•´é¡µæ»šåŠ¨ */
                position: fixed; /* å›ºå®šæ•´ä¸ªé¡µé¢ */
                width: 100%; /* ç¡®ä¿å®½åº¦100% */
                top: 0;
                left: 0;
            }
            .chat-container { 
                width: 100%; 
                height: 100%; 
                max-width: 100%; /* è¦†ç›–æ¡Œé¢ç«¯çš„ max-width */
                border-radius: 0;
                box-shadow: none;
                position: absolute; /* å›ºå®šèŠå¤©å®¹å™¨ */
                top: 0;
                left: 0;
                display: flex;
                flex-direction: column; /* ç§»åŠ¨ç«¯æ”¹ä¸ºåˆ—å¸ƒå±€ */
            }
            .main-chat {
                flex: 1;
                width: 100%;
                position: relative;
                overflow: hidden; /* é˜²æ­¢å®¹å™¨å¤–æº¢å‡º */
                display: flex;
                flex-direction: column;
            }
            #chat-window {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch; /* å…³é”®å±æ€§ */
                position: relative;
                z-index: 1; /* ç¡®ä¿æ»šåŠ¨åŒºåŸŸåœ¨é¡¶éƒ¨ */
            }
            .sidebar { 
                position: fixed; 
                left: -280px; 
                top: 0; 
                height: 100%; 
                z-index: 1000; 
                transition: left 0.3s ease; 
            }
            .sidebar.open { left: 0; }
            .sidebar-toggle { display: flex; }
            .chat-header { padding: 10px 15px; }
            .chat-info { gap: 10px; }
            .room-icon { width: 28px; height: 28px; font-size: 14px; }
            .room-name { font-size: 1em; }
            .user-status { font-size: 0.75em; }
            .online-users-display { margin-left: auto; font-size: 0.75em; padding: 4px 8px; }
            #message-form { 
                padding: 12px 15px; 
                padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
                position: relative;
                z-index: 2; /* ç¡®ä¿è¾“å…¥åŒºåŸŸåœ¨é¡¶éƒ¨ */
            }
            #message-input { padding: 10px 40px 10px 15px; font-size: 16px; }
            .users-menu { right: 15px; }
            .overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999; }
            .overlay.show { display: block; }
            .user-row { flex-direction: column; align-items: stretch; gap: 12px; }
            .user-names, .user-info { flex: none; width: 100%; }
            .message-image { max-width: 250px; }
        }
            .header-users {
                display: none;
            }

        /* è°ƒè¯•æ—¥å¿—æ ·å¼ */
        .debug-log-container {
            padding: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
            max-height: 950px;
            overflow-y: auto;
        }

        .debug-log-content {
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
            color: #e0e0e0;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 920px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .debug-log-content:empty::before {
            content: "æš‚æ— æ—¥å¿—æ•°æ®";
            color: rgba(255,255,255,0.5);
            font-style: italic;
        }

        .debug-log-entry {
            margin-bottom: 5px;
            padding: 2px 5px;
            border-radius: 3px;
            animation: fadeIn 0.3s ease;
        }

        .debug-log-entry.info { color: #90caf9; border-left: 3px solid #90caf9; }
        .debug-log-entry.success { color: #a5d6a7; border-left: 3px solid #a5d6a7; }
        .debug-log-entry.warning { color: #ffcc80; border-left: 3px solid #ffcc80; }
        .debug-log-entry.error { color: #ef9a9a; border-left: 3px solid #ef9a9a; }

        .debug-controls {
            display: inline-flex;
            gap: 5px;
            float: right;
        }

        .debug-controls button {
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            margin-right: 8px; 
            color: white;
            width: 24px;
            height: 24px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .debug-controls button:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .copy-feedback, .app-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: color-mix(in srgb, var(--accent) 90%, black);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .copy-feedback.show, .app-notification.show {
            opacity: 1;
        }

        .log-timestamp {
            color: rgba(255,255,255,0.5);
            margin-right: 5px;
            font-size: 0.85em;
        }
        .theme-toggle-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .theme-toggle-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }
        /* ä¸ºæ–°çš„å‘å¸ƒé€‰é¡¹æ·»åŠ ä¸€äº›æ ·å¼ï¼Œä½¿å…¶çªå‡º */
        .context-menu .publish-option {
            color: var(--accent); /* ä½¿ç”¨ä¸»é¢˜å¼ºè°ƒè‰² */
            font-weight: 600;
            border-top: 1px solid var(--border); /* ä¸å…¶ä»–é€‰é¡¹åˆ†éš” */
            margin-top: 5px;
            padding-top: 10px;
        }
        .context-menu .publish-option::before {
            content: 'ğŸš€'; /* ç«ç®­å›¾æ ‡ */
            margin-right: 8px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="overlay" id="overlay"></div>
        
        <div class="image-modal" id="image-modal">
            <button class="image-modal-close" id="modal-close">Ã—</button>
            <img id="modal-image" src="" alt="Preview">
        </div>
        
        <aside class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    <a href="https://chat.want.biz/management?secret=" class="header-link" style="text-decoration: none;">
                        <h2><span class="online-indicator"></span> ğŸ¤¹ æ´»è·ƒç”¨æˆ·</h2>
                    </a>
                    <button id="theme-toggle-btn" class="theme-toggle-btn" title="åˆ‡æ¢æ·±è‰²æ¨¡å¼">ğŸŒ“</button>
                </div>
            <div class="user-list-container">
                <div class="user-list-title">ğŸ  ç”¨æˆ· & æˆ¿é—´ä¿¡æ¯</div>
                <div class="user-row">
                    <!-- è¿™ä¸ªuser-names divå°†è¢«ç›´æ¥å¡«å……åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ -->
                    <div class="user-names" id="user-names"></div>
                    <div class="user-info">
                        <div class="info-row">
                            <span class="info-label">ğŸ›œ æ´»è·ƒ</span>
                            <span class="info-value online-count" id="online-count">0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">æˆ¿é—´</span>
                            <span class="info-value room-name-sidebar" id="sidebar-room-name">--</span>
                        </div>
                    </div>
                </div>
                <!-- è¿™é‡Œçš„ user-list ä¸å†éœ€è¦ï¼Œç”¨æˆ·åˆ—è¡¨å°†ç›´æ¥æ˜¾ç¤ºåœ¨ user-names ä¸­ -->
                <ul id="user-list" style="display: none;"></ul> 
            </div>
            <div class="user-stats-container">
                <div class="user-list-title">ğŸ• ç”¨æˆ·æ´»åŠ¨ç»Ÿè®¡</div>
                <div id="user-stats-list"></div>
            </div>
            <div class="debug-log-container">
                <div class="user-list-title">ğŸ è°ƒè¯•æ—¥å¿—
                    <div class="debug-controls">
                        <button id="clear-logs-btn" title="æ¸…ç©ºæ—¥å¿—">ğŸ’¥</button>
                        <button id="copy-logs-btn" title="å¤åˆ¶å…¨éƒ¨æ—¥å¿—">ğŸ“‹</button>
                        <button id="toggle-logs-btn" title="æ˜¾ç¤º/éšè—æ—¥å¿—">ğŸ¦‰</button>
                    </div>
                </div>
                <div id="debug-log-content" class="debug-log-content"></div>
            </div>
        </aside>

        <main class="main-chat">
            <header class="chat-header">
                <button class="sidebar-toggle" id="sidebar-toggle">â˜°</button>
                <div class="chat-info">
                    <div class="room-icon">âšœï¸</div>
                    <div class="chat-details">
                        <h1 class="room-name" id="room-name">Room: test</h1>
                        <p class="user-status">
                            <span class="connection-dot" id="connection-dot"></span>
                            <span id="status">æ­£åœ¨è¿æ¥...</span>
                            <span id="username-display" title="ç‚¹å‡»ä¿®æ”¹ç”¨æˆ·å"></span>
                        </p>
                    </div>
                </div>
                <div class="online-users-display" id="online-users-display">æ´»è·ƒ: 0</div>
                <div class="users-menu" id="users-menu">
                    <!-- users-menu-list å°†è¢«ç›´æ¥å¡«å……åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ -->
                    <ul id="users-menu-list"></ul>
                </div>
            </header>

            <div id="chat-window"></div>

            <form id="message-form">
                <button type="button" class="icon-btn" id="attachment-btn" title="æ·»åŠ å›¾ç‰‡">â•</button>
                <input type="file" id="image-input" accept="image/*">
                <div class="input-wrapper">
                    <div class="image-preview" id="image-preview">
                        <div class="upload-progress" id="upload-progress" style="display: none;"></div>
                        <div class="preview-content">
                            <img class="preview-image" id="preview-image" src="" alt="Preview">
                            <div class="preview-info">
                                <div class="preview-name" id="preview-name"></div>
                                <div class="preview-size" id="preview-size"></div>
                            </div>
                            <button type="button" class="preview-remove" id="preview-remove">Ã—</button>
                        </div>
                    </div>
                    <textarea id="message-input" placeholder="è¯·è¾“å…¥..." rows="1"></textarea>
                    <button type="button" class="clear-btn" id="clear-input-btn" title="æ¸…ç©ºè¾“å…¥æ¡†">Ã—</button>
                    <div id="mentions-suggestions" class="mentions-suggestions"></div>
                    <div class="voice-input-status" id="voice-input-status">æ­£åœ¨è†å¬...</div>
                </div>
                <button type="button" class="icon-btn" id="record-button" title="è¯­éŸ³è¾“å…¥">ğŸ¤</button>
                <button type="button" class="icon-btn" id="voice-input-button" title="è¯­éŸ³æé—®">ğŸ™ï¸</button>
                <button type="submit" class="icon-btn" id="send-button" title="å‘é€" disabled>ğŸš€</button>
            </form>
        </main>
    </div>

<div id="context-menu" class="context-menu">
    <ul>
        <li class="ai-explain-option" data-ai="gemini" data-action="text-explain">é—®Gemini</li>
        <li class="ai-explain-option" data-ai="deepseek" data-action="text-explain">DeepSeek</li>
        <li class="ai-explain-option" data-ai="kimi" data-action="text-explain">é—®Kimi</li>
        <li class="ai-explain-option" data-ai="gemini" data-action="image-describe">Geminiè¯»å›¾</li>
        <!-- ä¿®æ”¹è¿™é‡Œï¼Œæ·»åŠ  class="publish-option" -->
        <li class="publish-option" id="publish-toutiao-option">å‘å¤´æ¡</li>
        <li class="ai-explain-option" data-ai="kimi" data-action="image-describe">Kimiè¯»å›¾</li>
        <li id="copy-option">ğŸ“ å¤ åˆ¶</li>
        <li id="delete-option">âŒ åˆ  é™¤</li>
    </ul>
</div>
<div id="call-controls-container"></div>
<div id="remote-audio-container"></div>
<div id="app-notification" class="app-notification"></div>


<script type="module">
// åˆå§‹åŒ–ä¸»é¢˜ 
function initTheme() {
  const saved = localStorage.getItem('theme');
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const theme = saved ? saved : (prefersDark ? 'dark' : 'light');
  document.documentElement.setAttribute('data-theme', theme);
}
window.addEventListener('DOMContentLoaded', initTheme);

// åˆ‡æ¢æŒ‰é’®ç¤ºä¾‹ï¼ˆå¯æ”¾åœ¨ä¾§è¾¹æ æˆ–è®¾ç½®èœå•ï¼‰
function toggleTheme() {
  const current = document.documentElement.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
  const themeName = next === 'dark' ? 'æ·±è‰²' : 'æµ…è‰²';
  showAppNotification(`åˆ‡æ¢ä¸»é¢˜ (${themeName}) æˆåŠŸ`);
}

    // --- DOM Elements ---
const sidebarToggle = document.getElementById('sidebar-toggle');
const sidebar = document.getElementById('sidebar');
const overlay = document.getElementById('overlay');
const onlineDisplay = document.getElementById('online-users-display');
const usersMenu = document.getElementById('users-menu');
const attachmentBtn = document.getElementById('attachment-btn');
const imageInput = document.getElementById('image-input');
const imagePreview = document.getElementById('image-preview');
const previewImage = document.getElementById('preview-image');
const previewName = document.getElementById('preview-name');
const previewSize = document.getElementById('preview-size');
const previewRemove = document.getElementById('preview-remove');
const uploadProgress = document.getElementById('upload-progress');
const imageModal = document.getElementById('image-modal');
const modalImage = document.getElementById('modal-image');
const modalClose = document.getElementById('modal-close');
const recordButton = document.getElementById('record-button');
const voiceInputButton = document.getElementById('voice-input-button');
const voiceInputStatus = document.getElementById('voice-input-status');
const messageInput = document.getElementById('message-input');
const roomNameEl = document.getElementById('room-name');
const statusEl = document.getElementById('status');
const usernameDisplayEl = document.getElementById('username-display');
const connectionDot = document.getElementById('connection-dot');
const chatWindowEl = document.getElementById('chat-window');
const messageForm = document.getElementById('message-form');
const sendButton = document.getElementById('send-button');
const contextMenu = document.getElementById('context-menu'); // This is the fixed #context-menu element
const copyOption = document.getElementById('copy-option');
const deleteOption = document.getElementById('delete-option');
const callControlsContainer = document.getElementById('call-controls-container');
const remoteAudioContainer = document.getElementById('remote-audio-container');
const debugLogContent = document.getElementById('debug-log-content');
const clearLogsBtn = document.getElementById('clear-logs-btn');
const copyLogsBtn = document.getElementById('copy-logs-btn');
const toggleLogsBtn = document.getElementById('toggle-logs-btn');
const appNotification = document.getElementById('app-notification'); // New notification element
const mentionsSuggestions = document.getElementById('mentions-suggestions');
const themeToggleBtn = document.getElementById('theme-toggle-btn');
// Add reference to the publish option
const publishToutiaoOption = document.getElementById('publish-toutiao-option');


// ã€æ–°å¢ã€‘DOM å…ƒç´ å¼•ç”¨
const userNamesEl = document.getElementById('user-names'); // Sidebar user list
const menuListEl = document.getElementById('users-menu-list'); // Header dropdown user list
const onlineCountEl = document.getElementById('online-count'); // Sidebar online count


// --- å…¨å±€çŠ¶æ€å˜é‡ ---
let allMessages = []; // å­˜å‚¨æ‰€æœ‰æ¶ˆæ¯æ•°æ®
let messageIdSet = new Set(); // ç”¨äºå¿«é€Ÿå»é‡
let messageQueue = []; // æ¶ˆæ¯é˜Ÿåˆ—ï¼Œç”¨äºæ‰¹é‡å¤„ç†æ–°æ¶ˆæ¯
let rafScheduled = false; // requestAnimationFrame è°ƒåº¦æ ‡å¿—
let messageProcessTimeoutId = null; // ç”¨äº appendChatMessage çš„é˜²æŠ–å®šæ—¶å™¨ID
const MESSAGE_BATCH_DEBOUNCE_MS = 50; // æ‰¹é‡å¤„ç†æ¶ˆæ¯çš„é˜²æŠ–æ—¶é—´ (ä¿æŒæ‰¹å¤„ç†ï¼Œå³ä¾¿äººæ•°å°‘ï¼Œä¹Ÿèƒ½è®©UIæ›´æµç•…)

let hasMoreHistory = false; // ã€æ–°å¢ã€‘æ ‡å¿—ä½ï¼Œè¡¨ç¤ºæœåŠ¡å™¨æ˜¯å¦è¿˜æœ‰æ›´å¤šå†å²æ¶ˆæ¯
let isLoadingHistory = false; // ã€æ–°å¢ã€‘æ ‡å¿—ä½ï¼Œé˜²æ­¢é‡å¤åŠ è½½
let isConnecting = false; // ã€æ–°å¢ã€‘æ ‡å¿—ä½ï¼Œé˜²æ­¢å¹¶å‘è¿æ¥
    
let shouldReconnect = true; // ã€æ–°å¢ã€‘ä¸€ä¸ªå…¨å±€æ ‡å¿—ï¼Œæ§åˆ¶æ˜¯å¦å…è®¸é‡è¿
let reconnectIntervalId = null; // ã€æ–°å¢ã€‘ç”¨äºå­˜å‚¨é‡è¿å®šæ—¶å™¨ID

let selectedFile = null;
let mediaRecorder;
let audioChunks = [];
let isRecording = false;
let currentMessageElement = null; // ç”¨äºå­˜å‚¨å½“å‰å³é”®ç‚¹å‡»çš„æ¶ˆæ¯DOMå…ƒç´ 
let currentMessageData = null; // ç”¨äºå­˜å‚¨å½“å‰å³é”®ç‚¹å‡»çš„å®Œæ•´æ¶ˆæ¯æ•°æ®å¯¹è±¡

let socket;
let reconnectInterval = 1000;
const maxReconnectInterval = 30000;
let localStream = null;
const peerConnections = {};
const rtcConfig = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    {
      urls: [
        'turn:95.169.30.85:3478?transport=udp',
        'turn:95.169.30.85:3478?transport=tcp'
      ],
      username: 'yuangs',
      credential: 'yuangs123'
    }
  ]
};

// --- æ—¥å¿—åŠŸèƒ½å˜é‡ ---
const LOG_LEVELS = { INFO: 'info', SUCCESS: 'success', WARNING: 'warning', ERROR: 'error' };
const MAX_LOG_ENTRIES = 100;
let isDebugEnabled = true; // æ§åˆ¶æ˜¯å¦åœ¨DOMä¸­æ˜¾ç¤ºè°ƒè¯•æ—¥å¿—


// --- åˆå§‹åŒ–ç”¨æˆ·å’Œæˆ¿é—´ä¿¡æ¯ ---
let username = localStorage.getItem('chat_username');
if (!username) {
    username = prompt("è¯·è¾“å…¥æ‚¨çš„å§“å:") || "åŒ¿åç”¨æˆ·";
    localStorage.setItem('chat_username', username);
}
const pathParts = window.location.pathname.split('/');
const roomName = pathParts.find(p => p.trim()) || 'future';


// --- å·¥å…·å‡½æ•° ---
function escapeHTML(str) {
    if (typeof str !== 'string') return '';
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
    };
    return str.replace(/[&<>"']/g, m => map[m]);
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
}

// èŠ‚æµå‡½æ•° (ç»§ç»­ä¿ç•™ï¼Œé€šç”¨å®ç”¨)
function throttle(func, delay) {
    let timeoutId;
    let lastArgs;
    let lastThis;

    return function(...args) {
        lastArgs = args;
        lastThis = this;

        if (!timeoutId) {
            timeoutId = setTimeout(() => {
                func.apply(lastThis, lastArgs);
                timeoutId = null;
                lastArgs = null;
                lastThis = null;
            }, delay);
        }
    };
}


// --- è°ƒè¯•æ—¥å¿—ç³»ç»Ÿ (ä¿æŒä¸å˜) ---
function logDebug(message, level = LOG_LEVELS.INFO, data = null) {
    const consoleMethod = level === LOG_LEVELS.ERROR ? 'error' : 
                          level === LOG_LEVELS.WARNING ? 'warn' : 'log';
    
    if (data) {
        console[consoleMethod](`[${level.toUpperCase()}] ${message}`, data);
    } else {
        console[consoleMethod](`[${level.toUpperCase()}] ${message}`);
    }
    
    if (!isDebugEnabled || !debugLogContent) return;
    
    const fragment = document.createDocumentFragment();
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement('div');
    logEntry.className = `debug-log-entry ${level}`;
    
    let messageHTML = `<span class="log-timestamp">[${timestamp}]</span> <span>${message}</span>`;
    
    if (data) {
        let dataString;
        try {
            if (typeof data === 'object' && data !== null) {
                const limitedData = JSON.parse(JSON.stringify(data, (k, v) => {
                    if (typeof v === 'string' && v.length > 500) {
                        return v.substring(0, 500) + '... [æˆªæ–­]';
                    }
                    return v;
                }));
                dataString = JSON.stringify(limitedData, null, 2);
            } else {
                dataString = String(data);
            }
        } catch (e) {
            dataString = `[æ— æ³•åºåˆ—åŒ–çš„æ•°æ®: ${e.message}]`;
        }
        
        if (dataString.length > 1000) {
            dataString = dataString.substring(0, 1000) + '... [æ•°æ®è¿‡å¤§ï¼Œå·²æˆªæ–­]';
        }
        
        messageHTML += `<pre style="white-space: pre-wrap; word-break: break-all; margin-top: 5px; background: rgba(0,0,0,0.2); padding: 5px; border-radius: 4px;">${escapeHTML(dataString)}</pre>`;
    }
    
    logEntry.innerHTML = messageHTML;
    fragment.appendChild(logEntry);
    debugLogContent.appendChild(fragment);
    
    while (debugLogContent.children.length > MAX_LOG_ENTRIES) {
        debugLogContent.removeChild(debugLogContent.firstChild);
    }
    
    requestAnimationFrame(() => {
        debugLogContent.scrollTop = debugLogContent.scrollHeight;
    });
}

function initDebugLog() {
    if (clearLogsBtn) clearLogsBtn.addEventListener('click', clearLogs);
    if (copyLogsBtn) copyLogsBtn.addEventListener('click', copyLogs);
    if (toggleLogsBtn) toggleLogsBtn.addEventListener('click', toggleLogsDisplay);
    logDebug('ğŸ“— è°ƒè¯•æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', LOG_LEVELS.SUCCESS);
    logDebug(`ğŸ‘¦ å½“å‰ç”¨æˆ·: ${username}`, LOG_LEVELS.INFO);
    logDebug(`ğŸ  å½“å‰æˆ¿é—´: ${roomName}`, LOG_LEVELS.INFO);
    if (debugLogContent) {
        debugLogContent.style.display = isDebugEnabled ? '' : 'none';
    }
}

function clearLogs() {
    debugLogContent.innerHTML = '';
    logDebug('ğŸ§¹ æ—¥å¿—å·²æ¸…ç©º', LOG_LEVELS.INFO);
}

function copyLogs() {
    const logText = Array.from(debugLogContent.children).map(entry => entry.textContent).join('\n');
    navigator.clipboard.writeText(logText).then(() => {
        showAppNotification('æ—¥å¿—å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
        logDebug('æ—¥å¿—å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', LOG_LEVELS.SUCCESS);
    }).catch(err => logDebug(`å¤åˆ¶å¤±è´¥: ${err}`, LOG_LEVELS.ERROR));
}

function toggleLogsDisplay() {
    isDebugEnabled = !isDebugEnabled;
    if (debugLogContent) {
        debugLogContent.style.display = isDebugEnabled ? '' : 'none';
    }
    logDebug(`ğŸ“— è°ƒè¯•æ—¥å¿—æ˜¾ç¤ºå·²${isDebugEnabled ? 'å¼€å¯' : 'éšè—'}`, LOG_LEVELS.INFO);
}

function showAppNotification(message, duration = 2000, isError = false) {
    if (!appNotification) return;

    appNotification.textContent = message;
    appNotification.style.backgroundColor = isError ? '#e74c3c' : 'rgba(102, 126, 234, 0.9)';
    appNotification.classList.add('show');

    setTimeout(() => appNotification.classList.remove('show'), duration);
}


// --- UI æ¸²æŸ“å’Œæ›´æ–°é€»è¾‘ ---
// ä»…ç”¨äºæ›´æ–°ç”¨æˆ·æ´»åŠ¨ç»Ÿè®¡ï¼Œä¸å†å¤„ç†åœ¨çº¿ç”¨æˆ·åˆ—è¡¨çš„æ¸²æŸ“
const throttledUpdateActivityStats = throttle(updateUserActivityStats, 1000); 

function isUserActive(lastSeenTimestamp) {
    if (!lastSeenTimestamp) return false;
    const fiveMinutesInMs = 20 * 60 * 1000;
    const fiveMinutesAgo = Date.now() - fiveMinutesInMs;
    return new Date(lastSeenTimestamp).getTime() > fiveMinutesAgo;
}

// ã€ä¿®æ”¹ã€‘updateUIFromMessages æ›´åä¸º updateUserActivityStatsï¼Œå¹¶ä»…å¤„ç†æ´»åŠ¨ç»Ÿè®¡
function updateUserActivityStats() {
    const currentUserStates = new Map(); 

    // åªå¤„ç†æœ€è¿‘çš„500æ¡æ¶ˆæ¯ï¼ˆæˆ–æ ¹æ®éœ€è¦è°ƒæ•´ï¼‰
    const recentMessages = allMessages.slice(-500); 
    
    recentMessages.forEach(msg => {
        const { username, timestamp } = msg;
        if (!username) return; 

        const currentState = currentUserStates.get(username) || { lastSeen: 0, messageCount: 0 };
        currentState.lastSeen = Math.max(currentState.lastSeen, timestamp);
        currentState.messageCount++;
        currentUserStates.set(username, currentState);
    });

    // è®¡ç®—æ´»è·ƒçŠ¶æ€ï¼Œè™½ç„¶è¿™é‡Œä¸æ¸²æŸ“æ´»è·ƒç”¨æˆ·åˆ—è¡¨ï¼Œä½†ç»Ÿè®¡ä»æœ‰ç”¨
    currentUserStates.forEach((state, username) => {
        state.isActive = isUserActive(state.lastSeen);
    });

    const userStatsListEl = document.getElementById('user-stats-list');
    const allUsersSorted = Array.from(currentUserStates.keys()).sort((a, b) => {
        const aState = currentUserStates.get(a);
        const bState = currentUserStates.get(b);
        if (aState.isActive !== bState.isActive) return bState.isActive - aState.isActive; // æ´»è·ƒç”¨æˆ·ä¼˜å…ˆ
        return (bState.messageCount || 0) - (aState.messageCount || 0); // æ¶ˆæ¯æ•°é‡å¤šçš„ä¼˜å…ˆ
    });

    const statsFragment = document.createDocumentFragment();
    if (allUsersSorted.length === 0) {
        const emptyMsg = document.createElement('p');
        emptyMsg.style.color = 'rgba(255,255,255,0.7)';
        emptyMsg.style.fontSize = '0.8em';
        emptyMsg.textContent = 'æš‚æ— ç”¨æˆ·æ´»åŠ¨ã€‚';
        statsFragment.appendChild(emptyMsg);
    } else {
        allUsersSorted.forEach(name => {
            const state = currentUserStates.get(name);
            if (!state) return; 

            const item = document.createElement('div');
            item.className = 'user-stats-item';
            const isActive = state.isActive;
            const lastSeenString = state.lastSeen ? new Date(state.lastSeen).toLocaleString() : 'æœªçŸ¥';
            
            item.innerHTML = `
                <div class="stat-row">
                    <strong>${escapeHTML(name)}</strong>
                    <span class="${isActive ? 'online-status' : 'offline-status'}">${isActive ? 'æ´»è·ƒ' : 'ç¦»çº¿'}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">å‘è¨€:</span>
                    <span class="stat-value">${state.messageCount}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">æœ€è¿‘å‘è¨€:</span>
                    <span class="stat-value">${lastSeenString}</span>
                </div>`;
            statsFragment.appendChild(item);
        });
    }
    userStatsListEl.innerHTML = ''; 
    userStatsListEl.appendChild(statsFragment); 
}

// ã€æ–°å¢å‡½æ•°ã€‘æ ¹æ®åç«¯æ¨é€çš„åœ¨çº¿ç”¨æˆ·åˆ—è¡¨æ›´æ–°UI
function updateOnlineUserListDisplay(onlineUsers) {
    // æ¸…ç©ºç°æœ‰åˆ—è¡¨
    userNamesEl.innerHTML = '';
    menuListEl.innerHTML = '';

    const userNamesFragment = document.createDocumentFragment();
    const menuListFragment = document.createDocumentFragment();

    onlineUsers.forEach(user => {
        const safeUsername = escapeHTML(user.username);

        // æ·»åŠ åˆ°ä¾§è¾¹æ  user-names åˆ—è¡¨
        const userItem = document.createElement('div');
        userItem.className = 'user-item';
        userItem.dataset.id = user.id; // å¯ä»¥å­˜å‚¨ç”¨æˆ·ID
        userItem.dataset.username = user.username;
        userItem.textContent = safeUsername;
        userNamesFragment.appendChild(userItem);

        // æ·»åŠ åˆ°å¤´éƒ¨ä¸‹æ‹‰èœå• users-menu-list
        const menuItem = document.createElement('li');
        menuItem.dataset.id = user.id;
        menuItem.dataset.username = user.username;
        if (user.username === username) {
            menuItem.textContent = `${safeUsername} (ä½ )`;
        } else {
            menuItem.className = 'user-menu-item-with-call';
            const nameSpan = document.createElement('span');
            nameSpan.textContent = safeUsername;
            menuItem.appendChild(nameSpan);
            const callBtn = document.createElement('button');
            callBtn.className = 'call-btn';
            callBtn.textContent = 'ğŸ“';
            callBtn.dataset.username = safeUsername;
            callBtn.onclick = (e) => {
                e.stopPropagation();
                startCall(callBtn.dataset.username);
                usersMenu.classList.remove('show');
            };
            menuItem.appendChild(callBtn);
        }
        menuListFragment.appendChild(menuItem);
    });

    userNamesEl.appendChild(userNamesFragment);
    menuListEl.appendChild(menuListFragment);

    // æ›´æ–°åœ¨çº¿ç”¨æˆ·æ•°é‡æ˜¾ç¤º
    onlineCountEl.textContent = onlineUsers.length;
    onlineDisplay.textContent = `æ´»è·ƒ: ${onlineUsers.length}`;

    logDebug(`âœ… åœ¨çº¿ç”¨æˆ·ğŸ‘­åˆ—è¡¨å·²æ›´æ–° (${onlineUsers.length} äººåœ¨çº¿)`, LOG_LEVELS.INFO, onlineUsers.map(u => u.username));
    populateMentionsSuggestions(onlineUsers);
}

function populateMentionsSuggestions(users) {
    mentionsSuggestions.innerHTML = '';
    users.forEach(user => {
        const userItem = document.createElement('div');
        userItem.className = 'user-item';
        userItem.textContent = user.username;
        userItem.addEventListener('click', () => {
            const currentText = messageInput.value;
            const atIndex = currentText.lastIndexOf('@');
            const newText = currentText.substring(0, atIndex) + `@${user.username} `;
            messageInput.value = newText;
            mentionsSuggestions.style.display = 'none';
            messageInput.focus();
        });
        mentionsSuggestions.appendChild(userItem);
    });
}


// --- ç®€åŒ–æ¶ˆæ¯æ˜¾ç¤ºé€»è¾‘ (ä¸å†è™šæ‹Ÿæ»šåŠ¨) ---

// `appendMessagesToChatWindow` å‡½æ•°ï¼Œç”¨äºç›´æ¥è¿½åŠ æ¶ˆæ¯åˆ°èŠå¤©çª—å£
function appendMessagesToChatWindow(messages, scrollToBottom = true) {
    if (!chatWindowEl) {
        logDebug('â— èŠå¤©çª—å£å…ƒç´ æœªæ‰¾åˆ°ï¼Œæ— æ³•è¿½åŠ æ¶ˆæ¯', LOG_LEVELS.ERROR);
        return;
    }

    const fragment = document.createDocumentFragment();
    messages.forEach(msg => {
        if (!msg || !msg.id) {
            logDebug("â— å°è¯•è¿½åŠ æ— æ•ˆæ¶ˆæ¯", LOG_LEVELS.ERROR, msg);
            return;
        }
        const msgEl = createMessageElement(msg);
        fragment.appendChild(msgEl);
    });

    chatWindowEl.appendChild(fragment);

    if (scrollToBottom) {
        requestAnimationFrame(() => {
            chatWindowEl.scrollTop = chatWindowEl.scrollHeight;
        });
    }
}

// `initChatDisplay` å‡½æ•°ï¼Œæ›¿ä»£åŸå…ˆçš„ `initVirtualScrolling`
function initChatDisplay() {
    // æ¸…ç©ºæ‰€æœ‰æ—§æ¶ˆæ¯
    chatWindowEl.innerHTML = ''; 
    logDebug('âœ… èŠå¤©æ˜¾ç¤ºåˆå§‹åŒ–å®Œæˆ', LOG_LEVELS.SUCCESS);
    
    // æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬å™¨ï¼Œç”¨äºåŠ è½½æ›´å¤šå†å²æ¶ˆæ¯
    chatWindowEl.addEventListener('scroll', throttle(async () => {
        // å½“æ»šåŠ¨åˆ°é¡¶éƒ¨ï¼Œä¸”æœ‰æ›´å¤šå†å²è®°å½•ï¼Œä¸”å½“å‰æœªåœ¨åŠ è½½æ—¶
        if (chatWindowEl.scrollTop === 0 && hasMoreHistory && !isLoadingHistory) {
            await fetchMoreHistory();
        }
    }, 200)); // ä½¿ç”¨ 200ms çš„èŠ‚æµå»¶è¿Ÿ
}


// --- æ¶ˆæ¯æ¸²æŸ“å‡½æ•° (åˆ›å»ºå•ä¸ªDOMå…ƒç´ ï¼Œä¿æŒä¸å˜) ---
function createMessageElement(msg) {
    const msgEl = document.createElement('div');
    msgEl.className = 'message';
    
    // Store necessary data on dataset for easy access in showContextMenu later
    msgEl.dataset.id = msg.id;
    msgEl.dataset.messageText = msg.caption || msg.text || ''; 
    msgEl.dataset.timestamp = msg.timestamp;
    msgEl.dataset.messageType = msg.type;
    if (msg.type === 'image') {
        msgEl.dataset.imageUrl = msg.imageUrl;
    }

    if (msg.username === username) msgEl.classList.add('self');
    
    const messageDate = new Date(msg.timestamp);
    const now = new Date();
    const diffSeconds = Math.floor((now - messageDate) / 1000);
    let displayTime;
    if (diffSeconds < 60) displayTime = 'åˆšåˆš';
    else if (diffSeconds < 3600) displayTime = `${Math.floor(diffSeconds / 60)}åˆ†é’Ÿå‰`;
    else if (diffSeconds < 86400) displayTime = `${Math.floor(diffSeconds / 3600)}å°æ—¶å‰`;
    else displayTime = messageDate.toLocaleString([], { year: 'numeric', month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit' });
    
    let contentHTML = `<div class="info"><span class="username">${escapeHTML(msg.username)}</span> <span class="timestamp">${displayTime}</span></div>`;
            
    if (msg.type === 'image') {
        contentHTML += `<div class="message-image" onclick="showImageModal('${msg.imageUrl}')"><img src="${msg.imageUrl}" alt="${escapeHTML(msg.filename || 'Image')}" loading="lazy"></div>`;
        contentHTML += `<div class="text">${marked.parse(msg.caption || '')}</div>`; 
    } else if (msg.type === 'audio') {
        contentHTML += `<div class="message-audio"><audio controls src="${msg.audioUrl}"></audio></div>`;
        contentHTML += `<div class="text">${marked.parse(msg.text || '')}</div>`; 
    } else { 
        contentHTML += `<div class="text">${marked.parse(msg.text || '')}</div>`;
    }
        
    msgEl.innerHTML = contentHTML;
    
    // Add event listeners directly to msgEl for wider clickable area
    msgEl.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        // Pass the DOM element, the full message data, and coordinates
        showContextMenu(msgEl, msg, e.pageX, e.pageY); 
    });

    // Handle touch events for long press
    msgEl.addEventListener('touchstart', (e) => {
        // Store msg for touch context, and the full data object
        currentTouchMsgEl = msgEl;
        currentMessageData = msg; // Store the full data object
        touchStartTime = Date.now(); 

        touchLongPressTimer = setTimeout(() => {
            if (currentTouchMsgEl === msgEl && (Date.now() - touchStartTime) >= 500) {
                e.preventDefault(); // Prevent default browser context menu
                showContextMenu(msgEl, msg, e.touches[0].pageX, e.touches[0].pageY);
                if (navigator.vibrate) navigator.vibrate(50); 
            }
        }, 500); 
    }, { passive: true }); 

    // Reset on touchend or touchmove
    msgEl.addEventListener('touchend', () => {
        clearTimeout(touchLongPressTimer); 
        currentTouchMsgEl = null; 
    });

    msgEl.addEventListener('touchmove', () => {
        clearTimeout(touchLongPressTimer); 
        currentTouchMsgEl = null; 
    }, { passive: true }); 

    return msgEl;
}


// æ–°å¢çš„è¾…åŠ©å‡½æ•°ï¼šå»é™¤Markdownç¬¦å·
function stripMarkdown(text) {
    if (typeof text !== 'string') return '';
    // ç§»é™¤å¸¸è§çš„Markdownæ ¼å¼
    let cleaned = text.replace(/(\*\*|__|\*|_|#+)\s*(.*?)\s*(\*\*|__|\*|_)/g, '$2'); // **text**, *text*, ## text
    cleaned = cleaned.replace(/^-+\s*$/gm, ''); // æ°´å¹³åˆ†å‰²çº¿ ---
    cleaned = cleaned.replace(/^[*-]\s*/gm, ''); // åˆ—è¡¨é¡¹ - *
    cleaned = cleaned.replace(/^>\s*/gm, ''); // å¼•ç”¨å— >
    cleaned = cleaned.replace(/`{1,3}([^`]+?)`{1,3}/g, '$1'); // è¡Œå†…ä»£ç å’Œä»£ç å— `code`
    cleaned = cleaned.replace(/\[(.*?)\]\((.*?)\)/g, '$1'); // é“¾æ¥ [text](url) -> text
    
    // ç§»é™¤å¤šä½™çš„ç©ºæ ¼ï¼Œä½†ä¿ç•™æ¢è¡Œç¬¦
    cleaned = cleaned.replace(/[ \t]+/g, ' ').trim();
    return cleaned;
}

// ç®€åŒ–ç‰ˆAIå›å¤å†…å®¹å¤„ç†å™¨
class AIContentProcessor {
    constructor() {
        // å¸¸è§çš„AIå›å¤æ ‡è¯†ç¬¦
        this.aiIdentifiers = [
            '(æœºå™¨äººå°åŠ©æ‰‹)',
            '(ç”± Pro æ¨¡å‹ç”Ÿæˆ)',
            'ç”±.*?æ¨¡å‹ç”Ÿæˆ',
            'AIå›å¤',
            'æœºå™¨äººå°åŠ©æ‰‹:',
            'æœºå™¨äººå°åŠ©æ‰‹ï¼š',
            '**æœºå™¨äººå°åŠ©æ‰‹**:'
        ];
        
        // å¸¸è§çš„ç”¨æˆ·å‰ç¼€
        this.userPrefixes = [
            '@è‹‘å¹¿å±±',
            '@\\w+',
            'ç”¨æˆ·[ï¼š:]',
            'é—®é¢˜[ï¼š:]'
        ];
    }
    
    // ä¸€æ­¥åˆ°ä½çš„å†…å®¹æ¸…ç†
    cleanContent(text) {
        if (!text || typeof text !== 'string') return '';
        
        return text
            // ç§»é™¤æ§åˆ¶å­—ç¬¦
            .replace(/[\x00-\x09\x0B\x0C\x0E-\x1F\u200B-\u200F\u2028\u2029\uFEFF]/g, '')
            // æ¸…ç†HTMLæ ‡ç­¾
            .replace(/<[^>]*>/g, '')
            // æ¸…ç†Markdown
            .replace(/\*\*/g, '')
            .replace(/\*/g, '')
            .replace(/`/g, '')
            .replace(/#/g, '')

            // è§„èŒƒåŒ–ç©ºæ ¼å’Œæ¢è¡Œ
            .replace(/[ \t]+/g, ' ')
            .replace(/\n\s*\n\s*\n/g, '\n\n')
            .trim();
    }
    
    // æ™ºèƒ½æ£€æµ‹æ˜¯å¦ä¸ºAIå›å¤
    isAIResponse(message) {
        const text = message.text || message.caption || '';
        const username = message.username || '';
        
        // æ£€æŸ¥ç”¨æˆ·å
        if (username === 'æœºå™¨äººå°åŠ©æ‰‹') return true;
        
        // æ£€æŸ¥æ–‡æœ¬å†…å®¹
        return this.aiIdentifiers.some(identifier => 
            new RegExp(identifier, 'i').test(text)
        );
    }
    
    // ç§»é™¤AIæ ‡è¯†ç¬¦
    removeAIIdentifiers(text) {
        let cleaned = text;
        
        // ç§»é™¤AIç›¸å…³æ ‡è¯†
        const patterns = [
            /\*\*æœºå™¨äººå°åŠ©æ‰‹\*\*:\s*\(ç”±.*?æ¨¡å‹ç”Ÿæˆ\)/g,
            /æœºå™¨äººå°åŠ©æ‰‹:\s*\(ç”±.*?æ¨¡å‹ç”Ÿæˆ\)/g,
            /æœºå™¨äººå°åŠ©æ‰‹/g,
            /ç”±.*?æ¨¡å‹ç”Ÿæˆ/g,
            /\(ç”±.*?æ¨¡å‹ç”Ÿæˆ\)/g,
            /\[æœºå™¨äººå°åŠ©æ‰‹\]/g,
            /\[AIå›å¤\]/g
        ];
        
        patterns.forEach(pattern => {
            cleaned = cleaned.replace(pattern, '');
        });
        
        return cleaned.trim();
    }
    
    // ç§»é™¤ç”¨æˆ·å‰ç¼€
    removeUserPrefixes(text) {
        let cleaned = text;
        
        this.userPrefixes.forEach(prefix => {
            cleaned = cleaned.replace(new RegExp(`^\\s*${prefix}\\s*`, 'i'), '');
        });
        
        return cleaned.trim();
    }
    
    // æ™ºèƒ½åˆ†ç¦»æ ‡é¢˜å’Œå†…å®¹
    separateTitleAndContent(text) {
        const lines = text.split('\n').filter(line => line.trim().length > 0);
        
        if (lines.length === 0) {
            return { title: 'æ— æ ‡é¢˜', content: text };
        }
        
        if (lines.length === 1) {
            // å•è¡Œæ–‡æœ¬ï¼Œå°è¯•æŒ‰å†’å·åˆ†å‰²
            const colonIndex = text.indexOf(':');
            if (colonIndex !== -1 && colonIndex < 50) {
                return {
                    title: text.substring(0, colonIndex).trim(),
                    content: text.substring(colonIndex + 1).trim()
                };
            }
            
            // æ— æ³•åˆ†å‰²ï¼Œæˆªå–å‰30å­—ç¬¦ä½œä¸ºæ ‡é¢˜
            return {
                title: text.substring(0, Math.min(30, text.length)),
                content: text
            };
        }
        
        // å¤šè¡Œæ–‡æœ¬ï¼Œç¬¬ä¸€è¡Œä½œä¸ºæ ‡é¢˜
        return {
            title: lines[0].trim(),
            content: lines.slice(1).join('\n').trim()
        };
    }
    
    // æ ¼å¼åŒ–å†…å®¹ï¼ˆæ·»åŠ é€‚å½“çš„æ¢è¡Œï¼‰
    formatContent(content) {
        return content
            // æ•°å­—åˆ—è¡¨åæ¢è¡Œ (1. 2. 3. ç­‰)
            .replace(/(\d+\.\s*[^ã€‚ï¼ï¼Ÿ\.\!\?]*[ã€‚ï¼ï¼Ÿ\.\!\?])\s*/g, '$1\n\n')
            // å¥å·åæ¢è¡Œï¼Œä½†è¦è€ƒè™‘ä¸Šä¸‹æ–‡
            .replace(/([ã€‚ï¼ï¼Ÿ\.\!\?])\s*(?![0-9]|\)|\])/g, '$1\n')
            // å†’å·åæ¢è¡Œï¼ˆæ ‡é¢˜åï¼‰
            .replace(/([ï¼š:])\s*(?=\S)/g, '$1\n')
            // ç¡®ä¿æ®µè½åˆ†éš”
            .replace(/\n{3,}/g, '\n\n')
            // æ¸…ç†è¡Œé¦–ç©ºæ ¼
            .replace(/\n\s+/g, '\n')
            .trim();
    }
    
    // ä¸“é—¨å¤„ç†é•¿æ–‡æœ¬çš„æ®µè½åˆ†å‰²
    formatLongContent(content) {
        // å…ˆåŸºç¡€æ ¼å¼åŒ–
        let formatted = this.formatContent(content);
        
        // æ™ºèƒ½æ®µè½åˆ†å‰²
        const paragraphs = [];
        const sentences = formatted.split(/[ã€‚ï¼ï¼Ÿ\.\!\?]/);
        let currentParagraph = '';
        
        sentences.forEach((sentence, index) => {
            if (!sentence.trim()) return;
            
            // é‡æ–°æ·»åŠ æ ‡ç‚¹ç¬¦å·ï¼ˆé™¤äº†æœ€åä¸€ä¸ªï¼‰
            const punct = formatted.split(/[ã€‚ï¼ï¼Ÿ\.\!\?]/)[index] ? 
                formatted.match(/[ã€‚ï¼ï¼Ÿ\.\!\?]/g)?.[index] || '' : '';
            
            currentParagraph += sentence.trim() + punct;
            
            // è¾¾åˆ°ä¸€å®šé•¿åº¦æˆ–é‡åˆ°ç‰¹å®šæ ‡è¯†æ—¶åˆ†æ®µ
            if (currentParagraph.length > 100 || 
                sentence.includes('ï¼š') || 
                sentence.match(/^\s*\d+\./)) {
                
                if (currentParagraph.trim()) {
                    paragraphs.push(currentParagraph.trim());
                    currentParagraph = '';
                }
            }
        });
        
        // æ·»åŠ æœ€åä¸€æ®µ
        if (currentParagraph.trim()) {
            paragraphs.push(currentParagraph.trim());
        }
        
        return paragraphs.join('\n\n');
    }
    
    // è½¬æ¢ä¸ºHTMLæ ¼å¼ï¼ˆé€‚ç”¨äºå¤´æ¡å·ç­‰å¹³å°ï¼‰
    formatForHTML(content) {
        // å…ˆåŸºç¡€æ ¼å¼åŒ–
        let formatted = this.formatLongContent(content);
        
        // å°†æ¢è¡Œç¬¦è½¬æ¢ä¸ºHTML <br> æ ‡ç­¾
        formatted = formatted.replace(/\n\n/g, '<br><br>');
        formatted = formatted.replace(/\n/g, '<br>');
        
        return formatted;
    }
    
    // è½¬æ¢ä¸ºçº¯æ–‡æœ¬æ ¼å¼ï¼ˆä¿æŒåŸæœ‰çš„\næ¢è¡Œï¼‰
    formatForPlainText(content) {
        return this.formatLongContent(content);
    }
    
    // è§„èŒƒåŒ–æ ‡é¢˜é•¿åº¦
    normalizeTitle(title, minLength = 2, maxLength = 30) {
        if (!title || title.length < minLength) {
            return 'èŠå¤©è®°å½•';
        }
        
        if (title.length > maxLength) {
            return title.substring(0, maxLength - 3) + '...';
        }
        
        return title;
    }
    
    // ä¸»å¤„ç†å‡½æ•°
    processMessage(message) {
        try {
            // 1. è·å–åŸå§‹æ–‡æœ¬
            const rawText = message.text || message.caption || '';
            if (!rawText.trim()) {
                return {
                    title: message.type === 'image' ? 'å›¾ç‰‡åˆ†äº«' : 'ç©ºæ¶ˆæ¯',
                    content: message.type === 'image' ? 'ç”¨æˆ·åˆ†äº«äº†ä¸€å¼ å›¾ç‰‡' : 'æ¶ˆæ¯å†…å®¹ä¸ºç©º'
                };
            }
            
            // 2. åŸºç¡€æ¸…ç†
            let cleanedText = this.cleanContent(rawText);
            
            // 3. ç§»é™¤ç”¨æˆ·å‰ç¼€
            cleanedText = this.removeUserPrefixes(cleanedText);
            
            // 4. å¤„ç†AIå›å¤
            if (this.isAIResponse(message)) {
                cleanedText = this.removeAIIdentifiers(cleanedText);
            }
            
            // 5. åˆ†ç¦»æ ‡é¢˜å’Œå†…å®¹
            const { title: rawTitle, content: rawContent } = this.separateTitleAndContent(cleanedText);
            
            // 6. æ ¼å¼åŒ– - æ ¹æ®å¹³å°é€‰æ‹©æ ¼å¼
            const title = this.normalizeTitle(rawTitle);
            const content = this.formatForHTML(rawContent); // ä½¿ç”¨HTMLæ ¼å¼
            
            // 7. æœ€ç»ˆæ£€æŸ¥
            return {
                title: title || 'èŠå¤©è®°å½•',
                content: content || cleanedText || 'æ— å†…å®¹'
            };
            
        } catch (error) {
            console.error('å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™:', error);
            return {
                title: 'å¤„ç†å¤±è´¥',
                content: 'æ¶ˆæ¯å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯'
            };
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async function publishToToutiao(message) {
    try {
        const processor = new AIContentProcessor();
        const { title, content } = processor.processMessage(message, 'text'); // æŒ‡å®štextæ ¼å¼
        
        console.log('å¤„ç†ç»“æœ:', { title, content });
        
        // æ˜¾ç¤ºåŠ è½½æç¤º
        showAppNotification('æ­£åœ¨å‘å¸ƒåˆ°å¤´æ¡...', 2000);
        
        // å‘é€åˆ°åç«¯
        const response = await fetch('https://api.yuangs.cc/api/toutiaopost', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ title, content })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`å‘å¸ƒå¤±è´¥: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        console.log('å‘å¸ƒæˆåŠŸ:', data);
        showAppNotification('å·²æäº¤åˆ°å¤´æ¡ï¼Œç­‰å¾…å®¡æ ¸', 3000);
        
    } catch (error) {
        console.error('å‘å¸ƒå¤±è´¥:', error);
        showAppNotification(`å‘å¸ƒå¤±è´¥: ${error.message}`, 5000, true);
    }
}



function processMessageQueue() {
    if (isLoadingHistory) {
        logDebug("â— å†å²æ¶ˆæ¯åŠ è½½ä¸­ï¼Œæš‚åœå¤„ç†æ–°æ¶ˆæ¯é˜Ÿåˆ—ã€‚", LOG_LEVELS.INFO);
        rafScheduled = false;
        return;
    }

    if (messageQueue.length === 0) {
        rafScheduled = false;
        return;
    }

    const messagesToProcess = messageQueue.splice(0, messageQueue.length);
    const newMessagesToAppendToDOM = [];

    logDebug(`âœ… å¤„ç†æ¶ˆæ¯é˜Ÿåˆ—: ${messagesToProcess.length} æ¡æ¶ˆæ¯å¾…å¤„ç†`, LOG_LEVELS.INFO);

    messagesToProcess.forEach(msg => {
        const existingIndex = allMessages.findIndex(m => m.id === msg.id);
        
        if (existingIndex !== -1) {
            // æ¶ˆæ¯å·²å­˜åœ¨ï¼Œæ›´æ–°æ•°æ®
            allMessages[existingIndex] = msg;
            logDebug(`ğŸ”„ æ¶ˆæ¯æ•°æ®å·²æ›´æ–° (ID: ${msg.id})`, LOG_LEVELS.INFO);
            
            // æ›´æ–°DOMå…ƒç´ 
            const existingMsgEl = chatWindowEl.querySelector(`[data-id="${msg.id}"]`);
            if (existingMsgEl) {
                const updatedMsgEl = createMessageElement(msg);
                existingMsgEl.replaceWith(updatedMsgEl);
                logDebug(`ğŸ”„ æ¶ˆæ¯DOMå·²æ›´æ–° (ID: ${msg.id})`, LOG_LEVELS.INFO);
            } else {
                logDebug(`â— æ¶ˆæ¯ ${msg.id} æ•°æ®å·²æ›´æ–°ï¼Œä½†DOMå…ƒç´ æœªæ‰¾åˆ°ï¼Œå°†é‡æ–°è¿½åŠ `, LOG_LEVELS.WARNING);
                newMessagesToAppendToDOM.push(msg);
            }
        } else {
            // æ–°æ¶ˆæ¯
            allMessages.push(msg);
            messageIdSet.add(msg.id);
            newMessagesToAppendToDOM.push(msg);
            logDebug(`â• æ–°æ¶ˆæ¯å·²æ·»åŠ  (ID: ${msg.id})`, LOG_LEVELS.INFO);
        }
    });

    // ç»Ÿä¸€å¤„ç†éœ€è¦è¿½åŠ åˆ°DOMçš„æ–°æ¶ˆæ¯
    if (newMessagesToAppendToDOM.length > 0) {
        appendMessagesToChatWindow(newMessagesToAppendToDOM, true);
    } else {
        // å¦‚æœæœ‰æ›´æ–°æ“ä½œï¼Œä¹Ÿå°è¯•æ»šåŠ¨åˆ°åº•éƒ¨
        requestAnimationFrame(() => {
            chatWindowEl.scrollTop = chatWindowEl.scrollHeight;
        });
    }

    // å¤„ç†AIå›å¤çš„è¯­éŸ³æ’­æŠ¥
    messagesToProcess.forEach(msg => {
        if (msg.username === 'æœºå™¨äººå°åŠ©æ‰‹' && msg.text) {
            // æå–çº¯æ–‡æœ¬å†…å®¹è¿›è¡Œæ’­æŠ¥ï¼Œé¿å…Markdownè¯­æ³•å¹²æ‰°
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = marked.parse(msg.text || '', { gfm: true, breaks: true, sanitize: true });
            const plainText = tempDiv.textContent || tempDiv.innerText || '';
            speakText(plainText);
        }
    });

    // é™åˆ¶æ¶ˆæ¯æ•°é‡
    const MAX_ALL_MESSAGES = 500;
    while (allMessages.length > MAX_ALL_MESSAGES) {
        const removedMsg = allMessages.shift();
        messageIdSet.delete(removedMsg.id);
        const msgElToRemove = chatWindowEl.querySelector(`[data-id="${removedMsg.id}"]`);
        if (msgElToRemove) {
            msgElToRemove.remove();
        }
    }

    throttledUpdateActivityStats();

    if (messageQueue.length > 0) {
        requestAnimationFrame(processMessageQueue);
    } else {
        rafScheduled = false;
    }
}

// appendChatMessage (ä¿æŒæ‰¹å¤„ç†é˜²æŠ–æœºåˆ¶ï¼Œæœ‰åŠ©äºUIæµç•…æ€§)
function appendChatMessage(msg) {
    if (!msg || !msg.id) {
        logDebug("â— appendChatMessage æ”¶åˆ°æ— æ•ˆæ¶ˆæ¯", LOG_LEVELS.ERROR, msg);
        return;
    }
    


    messageQueue.push(msg);
    logDebug(`ğŸ“« æ¶ˆæ¯å…¥é˜Ÿ (ID: ${msg.id}). é˜Ÿåˆ—é•¿åº¦: ${messageQueue.length}`, LOG_LEVELS.INFO);

    if (messageProcessTimeoutId) {
        clearTimeout(messageProcessTimeoutId);
    }

    messageProcessTimeoutId = setTimeout(() => {
        messageProcessTimeoutId = null; 
        if (!rafScheduled) { 
            rafScheduled = true;
            requestAnimationFrame(processMessageQueue);
        }
    }, MESSAGE_BATCH_DEBOUNCE_MS);
}


// --- ä¸Šä¸‹æ–‡èœå•å’Œ AI è§£é‡Šé€»è¾‘ ---
// é‡å‘½åå¹¶ä¿®æ”¹å‚æ•°ï¼Œä½¿å…¶æ¥æ”¶ DOM å…ƒç´ å’Œå®Œæ•´æ¶ˆæ¯æ•°æ®å¯¹è±¡
function showContextMenu(element, messageData, x, y) {
    currentMessageElement = element; // Store the DOM element
    currentMessageData = messageData; // Store the full message data object

    if (!contextMenu) {
        console.warn('Context menu element not found');
        return;
    }
    
    // è®¾ç½®èœå•ä½ç½®å¹¶æ˜¾ç¤º
    contextMenu.style.top = `${y}px`;
    contextMenu.style.left = `${x}px`;
    contextMenu.style.display = 'block';

    const messageType = messageData.type; // Use messageData.type
    const isSelf = messageData.username === username; // Use messageData.username
    const messageContentText = messageData.text || messageData.caption || ''; // Use messageData for content

    // è·å–æ‰€æœ‰èœå•é¡¹çš„å¼•ç”¨
    const geminiTextOption = contextMenu.querySelector('[data-ai="gemini"][data-action="text-explain"]');
    const deepseekTextOption = contextMenu.querySelector('[data-ai="deepseek"][data-action="text-explain"]');
    const kimiTextOption = contextMenu.querySelector('[data-ai="kimi"][data-action="text-explain"]');
    const geminiImageOption = contextMenu.querySelector('[data-ai="gemini"][data-action="image-describe"]');
    const kimiImageOption = contextMenu.querySelector('[data-ai="kimi"][data-action="image-describe"]');
    const copyOption = document.getElementById('copy-option');
    const deleteOption = document.getElementById('delete-option');
    const publishToutiaoOption = document.getElementById('publish-toutiao-option');

    // é»˜è®¤éšè—æ‰€æœ‰AIå’ŒåŠŸèƒ½é€‰é¡¹
    geminiTextOption.style.display = 'none';
    deepseekTextOption.style.display = 'none';
    kimiTextOption.style.display = 'none';
    geminiImageOption.style.display = 'none';
    kimiImageOption.style.display = 'none';
    copyOption.style.display = 'none';
    deleteOption.style.display = 'none';
    publishToutiaoOption.style.display = 'none'; // é»˜è®¤éšè—å‘å¸ƒé€‰é¡¹
    
    // æ ¹æ®æ¶ˆæ¯ç±»å‹å†³å®šæ˜¾ç¤ºå“ªäº›é€‰é¡¹
    if (messageType === 'image') {
        geminiImageOption.style.display = 'flex'; 
        kimiImageOption.style.display = 'flex';
        // åªè¦æ˜¯å›¾ç‰‡æ¶ˆæ¯ï¼Œå°±æ˜¾ç¤ºå‘å¸ƒé€‰é¡¹ï¼ˆå³ä½¿æ²¡æœ‰æ–‡å­—æè¿°ä¹Ÿå¯ä»¥å‘å¸ƒï¼‰
        publishToutiaoOption.style.display = 'flex';
    } else if (messageType === 'text') {
        geminiTextOption.style.display = 'flex'; 
        deepseekTextOption.style.display = 'flex';
        kimiTextOption.style.display = 'flex';
        copyOption.style.display = 'flex';       
        // åªæœ‰æ–‡æœ¬æ¶ˆæ¯æœ‰å†…å®¹æ‰æ˜¾ç¤ºå‘å¸ƒé€‰é¡¹
        if (messageContentText.trim().length > 0) {
            publishToutiaoOption.style.display = 'flex';
        }
    }

    // åˆ é™¤é€‰é¡¹åªå¯¹è‡ªå·±å‘é€çš„æ¶ˆæ¯æ˜¾ç¤º
    deleteOption.style.display = isSelf ? 'flex' : 'none';
    
    if (navigator.vibrate) navigator.vibrate(50); 
}

if (contextMenu) {
    contextMenu.addEventListener('click', async (e) => {
    const clickedOption = e.target;
    if (!clickedOption.closest('li')) return; 

    const action = clickedOption.dataset.action;
    const model = clickedOption.dataset.ai;
    
    // ä½¿ç”¨ currentMessageData è€Œä¸æ˜¯ datasetï¼Œå› ä¸º currentMessageData æ˜¯å®Œæ•´çš„æ¶ˆæ¯å¯¹è±¡
    const originalMessageText = currentMessageData?.text || currentMessageData?.caption || '';
    const originalImageUrl = currentMessageData?.imageUrl;
    const messageType = currentMessageData?.type;


    contextMenu.style.display = 'none';

    if (clickedOption.id === 'copy-option') {
        if (originalMessageText) {
            navigator.clipboard.writeText(originalMessageText)
                .then(() => showAppNotification('æ–‡æœ¬å·²å¤åˆ¶!'))
                .catch(err => logDebug(`å¤åˆ¶å¤±è´¥: ${err}`, LOG_LEVELS.ERROR));
        }
        return; 
    }

    if (clickedOption.id === 'publish-toutiao-option') {
        // ç›´æ¥å°†å®Œæ•´çš„ currentMessageData å¯¹è±¡ä¼ é€’ç»™ publishToToutiao
        if (currentMessageData) {
            publishToToutiao(currentMessageData);
        } else {
            logDebug('å‘å¸ƒåˆ°å¤´æ¡ï¼šæ²¡æœ‰é€‰ä¸­çš„æ¶ˆæ¯æ•°æ®ã€‚', LOG_LEVELS.WARNING);
            showAppNotification('æ²¡æœ‰å¯å‘å¸ƒçš„æ¶ˆæ¯', 3000, true);
        }
        return;
    }

    if (clickedOption.id === 'delete-option') {
        if (currentMessageData?.id) {
            if (confirm("ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ")) {
                socket.send(JSON.stringify({ type: 'delete', payload: { id: currentMessageData.id } }));
                logDebug(`ğŸŸ¢ å‘é€åˆ é™¤æ¶ˆæ¯æŒ‡ä»¤: ${currentMessageData.id}`, LOG_LEVELS.INFO);
            }
        }
        return; 
    }

    let explanationText = "";
    let requestBody = {};
    let apiUrl = '';

    if (action === 'image-describe' && messageType === 'image') {
        if (!originalImageUrl) {
            logDebug("å›¾ç‰‡æè¿°ï¼šç¼ºå°‘å›¾ç‰‡URL", LOG_LEVELS.WARNING);
            return;
        }
        apiUrl = '/ai-describe-image';
        requestBody = { imageUrl: originalImageUrl, model: model };
        explanationText = `æ­£åœ¨é€šè¿‡ ${model} æ¨¡å‹è§£è¯»å›¾ç‰‡...`;
    } else if (action === 'text-explain' && messageType === 'text') {
        if (!originalMessageText) {
            logDebug("æ–‡æœ¬è§£é‡Šï¼šç¼ºå°‘æ–‡æœ¬å†…å®¹", LOG_LEVELS.WARNING);
            return;
        }
        apiUrl = '/ai-explain';
        requestBody = { text: originalMessageText, model: model };
        explanationText = `æ­£åœ¨é€šè¿‡ ${model} æ¨¡å‹æ€è€ƒä¸­...`;
    } else if (action === 'custom-prompt' && messageType === 'text') { 
        const customPrompt = prompt("è¯·è¾“å…¥æ‚¨çš„æç¤ºè¯:");
        if (!customPrompt || !originalMessageText) {
            logDebug("è‡ªå®šä¹‰æç¤ºè¯ï¼šç”¨æˆ·å–æ¶ˆæˆ–ç¼ºå°‘æ–‡æœ¬å†…å®¹", LOG_LEVELS.INFO);
            return;
        }
        apiUrl = '/ai-explain';
        requestBody = { text: `${originalMessageText}\n\n${customPrompt}`, model: 'gemini' }; 
        explanationText = `æ­£åœ¨ä½¿ç”¨æ‚¨çš„è‡ªå®šä¹‰æç¤ºè¯é€šè¿‡ Gemini æ¨¡å‹æ€è€ƒä¸­...`;
    } else {
        logDebug(`AIæ“ä½œå¤±è´¥ï¼šæœªçŸ¥åŠ¨ä½œæˆ–æ¶ˆæ¯ç±»å‹ä¸åŒ¹é…ã€‚Action: ${action}, Type: ${messageType}`, LOG_LEVELS.WARNING);
        return;
    }

    const existingExplanation = currentMessageElement?.querySelector('.ai-explanation'); // Use currentMessageElement (DOM)
    if (existingExplanation) {
        existingExplanation.remove();
    }
    
    const explanationEl = document.createElement('div');
    explanationEl.className = 'ai-explanation';
    explanationEl.innerHTML = `<p>ğŸ¤– ${explanationText}<span class="loading-dots"></span></p>`;
    currentMessageElement?.appendChild(explanationEl); // Append to currentMessageElement (DOM)

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText); 
        }
        
        const data = await response.json();
        const explanationContent = data.explanation || data.description; 
        
        explanationEl.innerHTML = ''; 
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'ai-explanation-buttons';

        const closeBtn = document.createElement('button');
        closeBtn.className = 'ai-explanation-close';
        closeBtn.innerHTML = 'Ã—';
        closeBtn.onclick = () => {
            explanationEl.remove();
            logDebug('AIè§£é‡Šå·²å…³é—­ã€‚', LOG_LEVELS.INFO);
        };

        const copyBtn = document.createElement('button');
        copyBtn.className = 'ai-explanation-copy';
        copyBtn.innerHTML = 'ğŸ“‹';
        copyBtn.title = 'å¤åˆ¶å†…å®¹';
        copyBtn.onclick = () => {
            navigator.clipboard.writeText(explanationContent)
                .then(() => showAppNotification('AIè§£é‡Šå·²å¤åˆ¶!'))
                .catch(err => logDebug(`AIè§£é‡Šå¤åˆ¶å¤±è´¥: ${err}`, LOG_LEVELS.ERROR));
        };

        buttonContainer.appendChild(copyBtn);
        buttonContainer.appendChild(closeBtn);

        const markdownContainer = document.createElement('div');
        markdownContainer.className = 'markdown-content';
        markdownContainer.innerHTML = marked.parse(explanationContent, { gfm: true, breaks: true, sanitize: true });
        
        explanationEl.appendChild(buttonContainer);
        explanationEl.appendChild(markdownContainer);
        logDebug(`AIè§£é‡ŠæˆåŠŸï¼Œæ¨¡å‹: ${model || 'å›¾ç‰‡æè¿°'}.`, LOG_LEVELS.SUCCESS);

    } catch (error) {
        logDebug(`è¯·æ±‚AIè§£é‡Šå¤±è´¥: ${error.message}`, LOG_LEVELS.ERROR, error);
        const errorModelName = (action === 'image-describe') ? 'AIå›¾ç‰‡æè¿°' : (model || 'æœªçŸ¥AIæ¨¡å‹');
        explanationEl.innerHTML = `<p>ğŸ˜ æŠ±æ­‰ï¼Œæ— æ³•ä» ${errorModelName} è·å–è§£é‡Š: ${escapeHTML(error.message)}</p>`;
        setTimeout(() => { if (explanationEl.parentNode) explanationEl.remove(); }, 6000); 
    }
});
}


// --- å›¾ç‰‡å’Œåª’ä½“å¤„ç†å‡½æ•° (ä¿æŒä¸å˜) ---
async function handleImageSelection(e) {
    const file = e.target.files[0];
    if (!file || !file.type.startsWith('image/')) return;
        removeImagePreview(); 
    try {
        uploadProgress.style.display = 'block';
        uploadProgress.textContent = 'å‹ç¼©ä¸­...';
        imagePreview.classList.add('show', 'uploading');
        const compressedBlob = await compressImage(file);
        selectedFile = new File([compressedBlob], file.name, { type: 'image/jpeg', lastModified: Date.now() });
        showImagePreview(selectedFile);
    } catch (error) {
        logDebug('å›¾ç‰‡å¤„ç†å¤±è´¥: ' + error, LOG_LEVELS.ERROR);
        showAppNotification('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•', 3000, true); 
    } finally {
        uploadProgress.style.display = 'none';
        imagePreview.classList.remove('uploading');
        checkSendButtonState();
    }
}

function compressImage(file, maxWidth = 800, maxHeight = 600, quality = 0.8) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            let { width, height } = img;
            if (width > height) {
                if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; }
            } else {
                if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; }
            }
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            canvas.toBlob(resolve, 'image/jpeg', quality);
        };
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
    });
}

function showImagePreview(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        previewImage.src = e.target.result;
        previewName.textContent = file.name;
        previewSize.textContent = formatFileSize(file.size);
        imagePreview.classList.add('show');
    };
    reader.readAsDataURL(file);
}

function removeImagePreview() {
    selectedFile = null;
    imagePreview.classList.remove('show');
    imageInput.value = '';
    checkSendButtonState();
}

async function handleRecordButtonClick() {
    if (isRecording) {
        mediaRecorder.stop();
        return;
    }
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const mimeType = ['audio/mp4', 'audio/webm;codecs=opus', 'audio/webm'].find(t => MediaRecorder.isTypeSupported(t));
        if (!mimeType) {
            showAppNotification('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½ã€‚', 3000, true); 
            return;
        }
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        audioChunks = [];
        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.onstart = () => {
            recordButton.textContent = 'ğŸ›‘';
            isRecording = true;
            checkSendButtonState();
        };
        mediaRecorder.onstop = () => {
            const audioBlob = new Blob(audioChunks, { type: mimeType });
            sendAudioMessage(audioBlob, mimeType);
            stream.getTracks().forEach(track => track.stop());
            recordButton.textContent = 'ğŸ¤';
            isRecording = false;
            checkSendButtonState();
        };
        mediaRecorder.start();
    } catch (error) {
        logDebug('ğŸ¤ æ— æ³•è®¿é—®éº¦å…‹é£: ' + error, LOG_LEVELS.ERROR);
        showAppNotification('ğŸ¤ æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚', 3000, true); 
    }
}

function checkSendButtonState() {
    sendButton.disabled = (messageInput.value.trim() === '' && selectedFile === null && !isRecording);
}


// --- æ¶ˆæ¯å‘é€å‡½æ•° (ä¿æŒä¸å˜) ---
// æ¨¡å‹é€‰æ‹©å¼¹å‡ºå±‚
const modelSelector = document.createElement('div');
modelSelector.id = 'model-selector';
modelSelector.innerHTML = `
    <div class="model-option" data-model="gemini">ğŸ¤– Gemini (æ¨¡å‹ä¸€)</div>
    <div class="model-option" data-model="deepseek">ğŸ§  DeepSeek (æ¨¡å‹äºŒ)</div>
    <div class="model-option" data-model="kimi">ğŸ¯ Kimi (æ¨¡å‹ä¸‰)</div>
`;
modelSelector.style.cssText = `
    position: absolute;
    background: white;
    border: 1px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1000;
    display: none;
    font-size: 14px;
    min-width: 150px;
    max-height: 200px;
    overflow-y: auto;
`;
document.body.appendChild(modelSelector);

// æ¨¡å‹é€‰æ‹©æ ·å¼
const modelStyle = document.createElement('style');
modelStyle.textContent = `
    .model-option {
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
        transition: background-color 0.2s;
    }
    .model-option:last-child {
        border-bottom: none;
    }
    .model-option:hover,
    .model-option.active {
        background-color: #f0f0f0;
    }
    .model-option.active {
        background-color: #e3f2fd;
        color: #1976d2;
    }
    
    /* å“åº”å¼è®¾è®¡ - ç§»åŠ¨ç«¯é€‚é… */
    @media (max-width: 768px) {
        #modelSelector {
            font-size: 14px;
            max-height: 200px !important;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            min-width: 120px;
            max-width: calc(100vw - 20px);
        }
        
        .model-option {
            padding: 12px 16px;
            font-size: 15px;
            line-height: 1.4;
        }
        
        .mentions-suggestions {
            font-size: 14px;
            max-height: 200px !important;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            min-width: 120px;
            max-width: calc(100vw - 20px);
        }
        
        .mentions-suggestions .user-item {
            padding: 12px 16px;
            font-size: 15px;
            line-height: 1.4;
        }
    }
    
    @media (max-width: 480px) {
        #modelSelector,
        .mentions-suggestions {
            max-height: 180px !important;
            font-size: 13px;
        }
        
        .model-option,
        .mentions-suggestions .user-item {
            padding: 10px 14px;
        }
    }
`;
document.head.appendChild(modelStyle);

messageForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const text = messageInput.value.trim();
    const isSocketReady = socket && socket.readyState === WebSocket.OPEN;

    if ((!text && !selectedFile && !isRecording) || !isSocketReady) {
        checkSendButtonState();
        return;
    }
    
    sendButton.disabled = true;
    
    try {
        if (selectedFile) {
            await sendImageMessage(selectedFile, text);
        } else if (text) {
            const tempId = crypto.randomUUID();
            const tempTimestamp = Date.now();

            // è§£æ@æŒ‡ä»¤
            let aiModel = null;
            let cleanText = text;
            
            if (text.includes('@deepseek')) {
                aiModel = 'deepseek';
                cleanText = text.replace(/@deepseek\s*/g, '').trim();
            } else if (text.includes('@gemini')) {
                aiModel = 'gemini';
                cleanText = text.replace(/@gemini\s*/g, '').trim();
            } else if (text.includes('@kimi')) {
                aiModel = 'kimi';
                cleanText = text.replace(/@kimi\s*/g, '').trim();
            } else if (/^\@|^@æœºå™¨äººå°åŠ©æ‰‹/.test(text)) {
                aiModel = 'gemini';
                cleanText = text.replace(/^@æœºå™¨äººå°åŠ©æ‰‹/, '').trim();
            }

            if (aiModel && cleanText) {
                // å‘é€åˆ°æŒ‡å®šAIæ¨¡å‹
                let messageType = 'gemini_chat';
                if (aiModel === 'kimi') {
                    messageType = 'kimi_chat';
                } else if (aiModel === 'deepseek') {
                    messageType = 'deepseek_chat';
                }
                
                socket.send(JSON.stringify({
                    type: messageType,
                    payload: {
                        id: tempId,
                        timestamp: tempTimestamp,
                        type: 'text',
                        text: cleanText,
                        original_user: username,
                        model: aiModel
                    }
                }));
            } else {
                // æ™®é€šèŠå¤©æ¶ˆæ¯
                socket.send(JSON.stringify({ 
                    type: 'chat', 
                    payload: { 
                        id: tempId,          
                        timestamp: tempTimestamp, 
                        type: 'text',
                        text: text 
                    } 
                }));
            }
            
            messageInput.value = '';
            messageInput.style.height = 'auto';
        }
    } catch (error) {
        logDebug('å‘é€æ¶ˆæ¯è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: ' + error, LOG_LEVELS.ERROR, error);
        showAppNotification('å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•', 3000, true); 
    } finally {
        removeImagePreview();
        checkSendButtonState();
    }
});

// --- å›¾ç‰‡æ–‡ä»¶ä¸Šä¼ å‡½æ•° (ä¿æŒä¸å˜) ---
async function sendImageMessage(file, caption = '') {
    try {
        logDebug(`ğŸš€ å¼€å§‹ä¸Šä¼ å›¾ç‰‡: ${file.name}`, LOG_LEVELS.INFO);
        
        uploadProgress.style.display = 'block';
        uploadProgress.textContent = 'ğŸš€ ä¸Šä¼ ä¸­...';
        imagePreview.classList.add('uploading');
        
        const safeFileName = encodeURIComponent(file.name);
        
        const response = await fetch('/upload', {
            method: 'POST',
            body: file,
            headers: {
                'X-Filename': safeFileName,
                'Content-Type': file.type
            }
        });
        
        if (!response.ok) {
            throw new Error(`ä¸Šä¼ å¤±è´¥: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.url) {
            throw new Error('æœåŠ¡å™¨æ²¡æœ‰è¿”å›æœ‰æ•ˆçš„æ–‡ä»¶URL');
        }
        // --- æ ¸å¿ƒæ”¹åŠ¨å¼€å§‹ ---
        // å¦‚æœç”¨æˆ·è¾“å…¥çš„ caption ä¸ºç©ºï¼Œåˆ™ä½¿ç”¨æ–‡ä»¶åä½œä¸ºé»˜è®¤ caption
        const finalCaption = caption.trim() === '' ? 'å›¾ç‰‡ï¼š' + file.name : 'å›¾ç‰‡ï¼š'+caption.trim();
        // --- æ ¸å¿ƒæ”¹åŠ¨ç»“æŸ ---
        
        logDebug(`âœ… å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼Œè·å–URL: ${data.url}`, LOG_LEVELS.SUCCESS);
        
        const tempId = crypto.randomUUID();
        const tempTimestamp = Date.now();

        const payload = {
            type: 'image',
            text: finalCaption, 
            caption: finalCaption,
            imageUrl: data.url, 
            filename: file.name,
            size: file.size,
            id: tempId,          
            timestamp: tempTimestamp
        };
        
        socket.send(JSON.stringify({
            type: 'chat',
            payload: payload
        }));
        
        logDebug("ğŸŸ¢ å›¾ç‰‡æ¶ˆæ¯å·²é€šè¿‡WebSocketå‘é€", LOG_LEVELS.SUCCESS);
        
        messageInput.value = '';
        messageInput.style.height = 'auto';
        removeImagePreview();
        
        return true;
    } catch (error) {
        logDebug(`â— å›¾ç‰‡ä¸Šä¼ å¤±è´¥: ${error.message}`, LOG_LEVELS.ERROR, error);
        showAppNotification(`â— å›¾ç‰‡ä¸Šä¼ å¤±è´¥: ${error.message}`, 3000, true); 
        throw error;
    } finally {
        uploadProgress.style.display = 'none';
        imagePreview.classList.remove('uploading');
    }
}

// --- éŸ³é¢‘æ–‡ä»¶ä¸Šä¼ å‡½æ•° (ä¿æŒä¸å˜) ---
async function sendAudioMessage(audioBlob, mimeType) {
    try {
        logDebug(`å¼€å§‹ä¸Šä¼ éŸ³é¢‘`, LOG_LEVELS.INFO, { size: audioBlob.size, type: mimeType });
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `audio-${timestamp}.${mimeType.includes('mp4') ? 'mp4' : 'webm'}`;
        const safeFileName = encodeURIComponent(filename);
        
        const response = await fetch('/upload', {
            method: 'POST',
            body: audioBlob,
            headers: {
                'X-Filename': safeFileName,
                'Content-Type': mimeType
            }
        });
        
        if (!response.ok) {
            throw new Error(`ä¸Šä¼ å¤±è´¥: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.url) {
            throw new Error('æœåŠ¡å™¨æ²¡æœ‰è¿”å›æœ‰æ•ˆçš„æ–‡ä»¶URL');
        }
        
        logDebug(`âœ… éŸ³é¢‘ä¸Šä¼ æˆåŠŸï¼Œè·å–URL: ${data.url}`, LOG_LEVELS.SUCCESS);
        
        const tempId = crypto.randomUUID();
        const tempTimestamp = Date.now();

        const payload = {
            type: 'audio',
            text: '', 
            audioUrl: data.url, 
            filename: filename,
            size: audioBlob.size,
            id: tempId,          
            timestamp: tempTimestamp
        };
        
        socket.send(JSON.stringify({
            type: 'chat',
            payload: payload
        }));
        
        logDebug("ğŸŸ¢ éŸ³é¢‘æ¶ˆæ¯å·²é€šè¿‡WebSocketå‘é€", LOG_LEVELS.SUCCESS);
        
        return true;
    } catch (error) {
        logDebug(`â— éŸ³é¢‘ä¸Šä¼ å¤±è´¥: ${error.message}`, LOG_LEVELS.ERROR, error);
        showAppNotification(`â— éŸ³é¢‘ä¸Šä¼ å¤±è´¥: ${error.message}`, 3000, true); 
        throw error;
    }
}

// ã€æ–°å¢ã€‘åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯çš„å‡½æ•°
async function fetchMoreHistory() {
    if (!hasMoreHistory || isLoadingHistory) return;

    logDebug('ğŸ“œ æ»šåŠ¨åˆ°é¡¶éƒ¨ï¼Œå¼€å§‹åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯...', LOG_LEVELS.INFO);
    isLoadingHistory = true;
    const loader = document.getElementById('history-loader');
    if (loader) {
        loader.textContent = 'åŠ è½½ä¸­...';
        loader.style.display = 'block';
    }

    try {
        const oldestMessage = allMessages[0];
        if (!oldestMessage) {
            logDebug('â— æ²¡æœ‰æ‰¾åˆ°æœ€æ—§çš„æ¶ˆæ¯ï¼Œæ— æ³•åŠ è½½æ›´å¤šå†å²ã€‚', LOG_LEVELS.WARNING);
            hasMoreHistory = false;
            return;
        }

        const beforeId = oldestMessage.id;
        const response = await fetch(`/api/messages/history?roomName=${roomName}&beforeId=${beforeId}`);
        
        if (!response.ok) {
            throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.statusText}`);
        }

        const data = await response.json();
        const newHistory = data.messages;
        hasMoreHistory = data.hasMore;

        if (newHistory && newHistory.length > 0) {
            logDebug(`âœ… æˆåŠŸè·å– ${newHistory.length} æ¡æ›´æ—©çš„å†å²æ¶ˆæ¯ã€‚`, LOG_LEVELS.SUCCESS);
            
            const oldScrollHeight = chatWindowEl.scrollHeight;
            
            for (let i = newHistory.length - 1; i >= 0; i--) {
                const msg = newHistory[i];
                if (!messageIdSet.has(msg.id)) {
                    allMessages.unshift(msg);
                    messageIdSet.add(msg.id);
                    const msgEl = createMessageElement(msg);
                    chatWindowEl.insertBefore(msgEl, loader.nextSibling);
                }
            }

            requestAnimationFrame(() => {
                chatWindowEl.scrollTop = chatWindowEl.scrollHeight - oldScrollHeight;
            });

        } else {
            logDebug('â„¹ï¸ APIè¿”å›äº†0æ¡æ¶ˆæ¯ï¼Œæ²¡æœ‰æ›´å¤šå†å²äº†ã€‚', LOG_LEVELS.INFO);
            hasMoreHistory = false;
        }

    } catch (error) {
        logDebug(`â— åŠ è½½å†å²æ¶ˆæ¯å¤±è´¥: ${error.message}`, LOG_LEVELS.ERROR, error);
        showAppNotification('åŠ è½½å†å²æ¶ˆæ¯å¤±è´¥', 3000, true);
    } finally {
        isLoadingHistory = false;
        if (loader) {
            if (!hasMoreHistory) {
                loader.textContent = 'å·²åŠ è½½æ‰€æœ‰å†å²è®°å½•';
                loader.style.display = 'block';
            } else {
                loader.style.display = 'none';
            }
        }
    }
}

// ã€ç®€åŒ–ã€‘å¤„ç†åˆå§‹å†å²æ¶ˆæ¯çš„å‡½æ•°
function processHistoryMessages(history) {
    if (!Array.isArray(history)) {
        logDebug("â— åˆå§‹å†å²è®°å½•æ ¼å¼ä¸æ­£ç¡®ï¼Œå·²å¿½ç•¥ã€‚", LOG_LEVELS.WARNING);
        return;
    }
    
    logDebug(`ğŸ§® å¼€å§‹å¤„ç† ${history.length} æ¡åˆå§‹å†å²è®°å½•...`);
    
    allMessages = [];
    messageIdSet.clear(); 
    chatWindowEl.innerHTML = ''; 
    
    const loader = document.createElement('div');
    loader.id = 'history-loader';
    loader.style.cssText = 'text-align: center; padding: 10px; font-size: 0.8em; color: #6c757d; display: none;';
    loader.textContent = 'åŠ è½½ä¸­...';
    chatWindowEl.appendChild(loader);

    const validHistory = history.filter(msg => {
        if (msg && msg.id && !messageIdSet.has(msg.id)) {
            messageIdSet.add(msg.id);
            return true;
        }
        return false;
    });

    allMessages = validHistory;
    
    appendMessagesToChatWindow(allMessages, true);
    throttledUpdateActivityStats();
    logDebug("âœ… åˆå§‹å†å²è®°å½•å¤„ç†å®Œæ¯•ã€‚", LOG_LEVELS.SUCCESS);
    
    if (!hasMoreHistory && loader) {
        loader.textContent = 'å·²åŠ è½½æ‰€æœ‰å†å²è®°å½•';
        loader.style.display = 'block';
    }
}


// ã€ç®€åŒ–ã€‘connectWebSocket å‡½æ•°
function connectWebSocket() {
    if (isConnecting || (socket && socket.readyState === WebSocket.OPEN)) {
        logDebug('ğŸ”— è¿æ¥å·²å­˜åœ¨æˆ–æ­£åœ¨è¿›è¡Œä¸­ï¼Œå¿½ç•¥æ–°çš„è¿æ¥è¯·æ±‚ã€‚');
        return;
    }
    isConnecting = true;

    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/${roomName}?username=${encodeURIComponent(username)}`;
    logDebug(`ğŸš€ å¼€å§‹è¿æ¥WebSocket: ${wsUrl}`, LOG_LEVELS.INFO);
    socket = new WebSocket(wsUrl);
    socket.onopen = onSocketOpen;
    socket.onmessage = onSocketMessage;
    socket.onclose = onSocketClose;
    socket.onerror = onSocketError;
}

// ã€ç®€åŒ–ã€‘onSocketOpen å‡½æ•°
function onSocketOpen() {
    isConnecting = false;
    logDebug('ğŸŸ¢ WebSocket è¿æ¥å·²æ‰“å¼€ (onopenè§¦å‘)ã€‚');
    statusEl.textContent = 'å·²è¿æ¥';
    connectionDot.classList.remove('disconnected');
    
    // æˆåŠŸæ‰“å¼€åï¼Œé‡ç½®é‡è¿é—´éš”
    reconnectInterval = 1000;
    
    checkSendButtonState();
    // è¿æ¥æˆåŠŸåï¼Œç«‹å³è§¦å‘ä¸€æ¬¡é˜Ÿåˆ—å¤„ç†ï¼Œä»¥é˜²åœ¨æ–­çº¿æœŸé—´æœ‰æ¶ˆæ¯ç§¯å‹
    if (messageQueue.length > 0 && !rafScheduled) {
        rafScheduled = true;
        requestAnimationFrame(processMessageQueue);
    }
}
const messageHandlers = {

    // ã€æ–°å¢ã€‘å¤„ç†æˆæƒå¤±è´¥çš„æ¶ˆæ¯
    auth_failed: (payload) => {
        logDebug(`ğŸš« æˆæƒå¤±è´¥: ${payload.message}`, LOG_LEVELS.ERROR);
        const fullMessage = `${payload.message}\n\nå¦‚éœ€è®¿é—®ï¼Œè¯·è”ç³»ç®¡ç†å‘˜: ${payload.contact}`;
        
        alert(fullMessage);
        
        statusEl.textContent = "æ— æƒé™è®¿é—®";
        sendButton.disabled = true;
        messageInput.disabled = true; 
        attachmentBtn.disabled = true;
        imageInput.disabled = true; // ç¡®ä¿éšè—çš„ input ä¹Ÿè¢«ç¦ç”¨
        recordButton.disabled = true; 
        // ç¡®ä¿ `shouldReconnect` æ ‡å¿—è®¾ç½®ä¸º falseï¼Œé˜»æ­¢æ‰€æœ‰é‡è¿å°è¯•
        shouldReconnect = false; 
    },
    welcome: (payload) => {
        const history = payload?.history;
        hasMoreHistory = payload?.hasMoreHistory || false; 
        
        if (Array.isArray(history)) {
            processHistoryMessages(history);
        } else {
            logDebug("æ”¶åˆ°çš„æ¬¢è¿æ¶ˆæ¯ä¸­ history æ ¼å¼ä¸æ­£ç¡®æˆ–ä¸å­˜åœ¨ã€‚", LOG_LEVELS.ERROR, payload);
        }
    },
    chat: (payload) => {
        const newMessage = payload;
        if (newMessage && newMessage.id) {
            appendChatMessage(newMessage);
        }
        throttledUpdateActivityStats(); // ã€æ–°å¢ã€‘æ¯æ¬¡æ”¶åˆ°èŠå¤©æ¶ˆæ¯åæ›´æ–°æ´»åŠ¨ç»Ÿè®¡
    },
    // user_join å’Œ user_leave æ¶ˆæ¯ä¸å†ç›´æ¥æ›´æ–°åˆ—è¡¨ï¼Œè€Œæ˜¯ä¾èµ– user_list_update
    user_join: (payload) => {
        logDebug(`ğŸ‘ å‰ç«¯æ¶ˆæ¯: ${payload.username} åŠ å…¥äº†`, LOG_LEVELS.INFO, payload);
        //throttledUpdateActivityStats(); // ç§»é™¤ï¼Œå› ä¸º user_list_update ä¼šå¤„ç†
    },
    user_leave: (payload) => {
        logDebug(`ğŸ’¤ å‰ç«¯æ¶ˆæ¯: ${payload.username} ç¦»å¼€äº†`, LOG_LEVELS.INFO, payload);
        //throttledUpdateActivityStats(); // ç§»é™¤ï¼Œå› ä¸º user_list_update ä¼šå¤„ç†
    },
    delete: (payload) => {
        const { messageId } = payload;
        if (messageId) {
            logDebug(`â¬‡ï¸ æ”¶åˆ°åˆ é™¤æŒ‡ä»¤ï¼Œå‡†å¤‡ç§»é™¤æ¶ˆæ¯: ${messageId}`, LOG_LEVELS.WARNING);
            allMessages = allMessages.filter(m => m.id !== messageId);
            messageIdSet.delete(messageId); 
            // ç›´æ¥ä» DOM ç§»é™¤å¯¹åº”çš„æ¶ˆæ¯å…ƒç´ 
            const msgElToDelete = chatWindowEl.querySelector(`[data-id="${messageId}"]`);
            if (msgElToDelete) {
                msgElToDelete.remove();
            }
            throttledUpdateActivityStats(); // æ¶ˆæ¯åˆ é™¤åæ›´æ–°æ´»åŠ¨ç»Ÿè®¡
        }
    },
    error: (payload) => {
        logDebug(`â¬‡ï¸ æ”¶åˆ°åç«¯é”™è¯¯é€šçŸ¥: ${payload?.message}`, LOG_LEVELS.ERROR, payload);
        showAppNotification(payload?.message || "å‘ç”ŸæœªçŸ¥é”™è¯¯", 5000, true); 
        sendButton.disabled = false;
    },
    offer: (payload) => handleOffer(payload),
    answer: (payload) => handleAnswer(payload),
    candidate: (payload) => handleCandidate(payload),
    call_end: (payload) => handleCallEnd(payload),
    debug_log: (payload) => {
        logDebug(`[åç«¯æ—¥å¿—] ${payload.message}`, payload.level.toLowerCase(), payload.data);
    },
    heartbeat: () => {
        // æ”¶åˆ°æœåŠ¡å™¨å¿ƒè·³åï¼Œç«‹å³å›å¤ä¸€ä¸ªï¼Œä»¥ä¿æŒè¿æ¥æ´»è·ƒ
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'heartbeat' }));
        }
    },
    system_notification: (payload) => { 
        logDebug(`[ç³»ç»Ÿé€šçŸ¥] ${payload.message}`, payload.level.toLowerCase(), payload);
        showAppNotification(payload.message, 5000, payload.level === 'ERROR');
    },
    // ã€æ–°å¢ã€‘å¤„ç†åœ¨çº¿ç”¨æˆ·åˆ—è¡¨æ›´æ–°æ¶ˆæ¯
    user_list_update: (payload) => {
        const botUser = { id: 'robot-assistant', username: 'æœºå™¨äººå°åŠ©æ‰‹' };

        if (Array.isArray(payload.users)) {
            // è¿‡æ»¤æ‰ä»»ä½•å¯èƒ½æ¥è‡ªåç«¯çš„åŒåæœºå™¨äººï¼Œç„¶åå°†æˆ‘ä»¬çš„é™æ€æœºå™¨äººæ·»åŠ åˆ°åˆ—è¡¨å¼€å¤´
            const filteredUsers = payload.users.filter(u => u.username !== botUser.username);
            const finalUsers = [botUser, ...filteredUsers];
            
            updateOnlineUserListDisplay(finalUsers);
            logDebug(`âœ… æ”¶åˆ°åœ¨çº¿ç”¨æˆ·åˆ—è¡¨æ›´æ–°ï¼Œå½“å‰ ğŸ‘­${payload.users.length} ä½çœŸå®ç”¨æˆ·åœ¨çº¿ (å·²æ·»åŠ æœºå™¨äºº)`, LOG_LEVELS.INFO, finalUsers.map(u => u.username));
        } else {
            logDebug("â— æ”¶åˆ°ç”¨æˆ·åˆ—è¡¨æ›´æ–°ï¼Œä½†æ ¼å¼ä¸æ­£ç¡®ã€‚", LOG_LEVELS.ERROR, payload);
        }
    }
};

// è·å–æ¸…é™¤æŒ‰é’®å…ƒç´ 
const clearInputBtn = document.getElementById('clear-input-btn');

messageInput.addEventListener('input', () => {
    const text = messageInput.value;
    const atIndex = text.lastIndexOf('@');
    const slashIndex = text.lastIndexOf('/');

    // æ˜¾ç¤º/éšè—æ¸…é™¤æŒ‰é’®
    if (text.trim().length > 0) {
        clearInputBtn.style.display = 'flex';
    } else {
        clearInputBtn.style.display = 'none';
    }

    // éšè—æ¨¡å‹é€‰æ‹©å™¨
    modelSelector.style.display = 'none';
    // éšè—æ—¶è¿”å›åˆ°bodyï¼Œé¿å…å½±å“å…¶ä»–å®šä½
    if (modelSelector.parentElement !== document.body) {
        document.body.appendChild(modelSelector);
    }

    // å¤„ç†@æåŠ
    if (atIndex !== -1 && (slashIndex === -1 || atIndex > slashIndex)) {
        const query = text.substring(atIndex + 1);
        const onlineUsers = Array.from(userNamesEl.children).map(el => el.dataset.username);
        const filteredUsers = onlineUsers.filter(user => user.toLowerCase().includes(query.toLowerCase()));
        populateMentionsSuggestions(filteredUsers.map(username => ({ username })));
        
        if (filteredUsers.length > 0) {
            const inputWrapper = messageInput.parentElement;
            const position = smartPosition(mentionsSuggestions, inputWrapper);
            
            Object.assign(mentionsSuggestions.style, position);
            mentionsSuggestions.style.display = 'block';
            
            // ç¡®ä¿é™„åŠ åˆ°æ­£ç¡®çš„å®¹å™¨
            if (mentionsSuggestions.parentElement !== inputWrapper) {
                inputWrapper.appendChild(mentionsSuggestions);
            }
        } else {
            mentionsSuggestions.style.display = 'none';
        }
    } else {
        mentionsSuggestions.style.display = 'none';
    }

    // æ™ºèƒ½å®šä½å‡½æ•° - ç¡®ä¿å…ƒç´ å§‹ç»ˆåœ¨å±å¹•å†…å¯è§
    function smartPosition(element, anchorElement) {
        const anchorRect = anchorElement.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        const elementHeight = element.offsetHeight || 150;
        const elementWidth = element.offsetWidth || 150;
        
        // è®¡ç®—å¯ç”¨ç©ºé—´
        const spaceAbove = anchorRect.top;
        const spaceBelow = viewportHeight - anchorRect.bottom;
        const spaceRight = viewportWidth - anchorRect.left;
        const spaceLeft = anchorRect.right;
        
        let position = {
            position: 'absolute',
            zIndex: '1000'
        };
        
        // å‚ç›´æ–¹å‘ï¼šä¼˜å…ˆæ˜¾ç¤ºåœ¨ä¸‹æ–¹ï¼Œå¦‚æœä¸‹æ–¹ç©ºé—´ä¸è¶³åˆ™æ˜¾ç¤ºåœ¨ä¸Šæ–¹
        if (spaceBelow >= Math.min(elementHeight, 150) + 10) {
            // æ˜¾ç¤ºåœ¨ä¸‹æ–¹
            position.top = '100%';
            position.bottom = 'auto';
            position.marginTop = '5px';
            position.marginBottom = '0';
            position.maxHeight = Math.min(elementHeight, spaceBelow - 10) + 'px';
        } else if (spaceAbove >= Math.min(elementHeight, 150) + 10) {
            // æ˜¾ç¤ºåœ¨ä¸Šæ–¹
            position.bottom = '100%';
            position.top = 'auto';
            position.marginBottom = '5px';
            position.marginTop = '0';
            position.maxHeight = Math.min(elementHeight, spaceAbove - 10) + 'px';
        } else {
            // ç©ºé—´ä¸è¶³ï¼Œæ ¹æ®æ›´å¤§ç©ºé—´å†³å®š
            if (spaceBelow > spaceAbove) {
                position.top = '100%';
                position.bottom = 'auto';
                position.maxHeight = Math.max(50, spaceBelow - 10) + 'px';
            } else {
                position.bottom = '100%';
                position.top = 'auto';
                position.maxHeight = Math.max(50, spaceAbove - 10) + 'px';
            }
        }
        
        // æ°´å¹³æ–¹å‘ï¼šç¡®ä¿ä¸è¶…å‡ºå±å¹•è¾¹ç•Œ
        const minWidth = Math.min(150, viewportWidth - 20);
        
        if (spaceRight >= minWidth) {
            // å·¦å¯¹é½
            position.left = '0';
            position.right = 'auto';
        } else if (spaceLeft >= minWidth) {
            // å³å¯¹é½
            position.right = '0';
            position.left = 'auto';
        } else {
            // å±…ä¸­æ˜¾ç¤º
            const availableWidth = Math.min(viewportWidth - 20, Math.max(elementWidth, 150));
            const leftOffset = Math.max(10, (viewportWidth - availableWidth) / 2 - anchorRect.left);
            position.left = leftOffset + 'px';
            position.right = 'auto';
            position.width = availableWidth + 'px';
        }
        
        return position;
    }

    // å¤„ç†/å¿«æ·é€‰æ‹©æ¨¡å‹
    if (slashIndex !== -1 && slashIndex === text.length - 1 && text.length === 1) {
        // åªåœ¨å•ç‹¬è¾“å…¥/æ—¶æ˜¾ç¤º
        const inputWrapper = messageInput.parentElement;
        const position = smartPosition(modelSelector, inputWrapper);
        
        Object.assign(modelSelector.style, position);
        modelSelector.style.display = 'block';
        
        // å°†é€‰æ‹©å™¨é™„åŠ åˆ°è¾“å…¥æ¡†å®¹å™¨å†…
        if (modelSelector.parentElement !== inputWrapper) {
            inputWrapper.appendChild(modelSelector);
        }
    }
});

// æ¨¡å‹é€‰æ‹©äº‹ä»¶å¤„ç†
modelSelector.addEventListener('click', (e) => {
    if (e.target.classList.contains('model-option')) {
        const model = e.target.dataset.model;
        const modelMap = {
            'gemini': '@gemini',
            'deepseek': '@deepseek',
            'kimi': '@kimi'
        };
        messageInput.value = messageInput.value.replace(/\/$/, modelMap[model] + ' ');
        modelSelector.style.display = 'none';
        // éšè—æ—¶è¿”å›åˆ°bodyï¼Œé¿å…å½±å“å…¶ä»–å®šä½
        if (modelSelector.parentElement !== document.body) {
            document.body.appendChild(modelSelector);
        }
        // éšè—æ—¶è¿”å›åˆ°bodyï¼Œé¿å…å½±å“å…¶ä»–å®šä½
        if (modelSelector.parentElement !== document.body) {
            document.body.appendChild(modelSelector);
        }
        // éšè—æ—¶è¿”å›åˆ°bodyï¼Œé¿å…å½±å“å…¶ä»–å®šä½
        if (modelSelector.parentElement !== document.body) {
            document.body.appendChild(modelSelector);
        }
        messageInput.focus();
        messageInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
});

// ç‚¹å‡»å¤–éƒ¨å…³é—­æ¨¡å‹é€‰æ‹©å™¨
document.addEventListener('click', (e) => {
    if (!modelSelector.contains(e.target) && e.target !== messageInput) {
        modelSelector.style.display = 'none';
    }
});

// æ¸…é™¤æŒ‰é’®ç‚¹å‡»äº‹ä»¶
clearInputBtn.addEventListener('click', () => {
    messageInput.value = '';
    clearInputBtn.style.display = 'none';
    messageInput.focus();
    
    // è§¦å‘inputäº‹ä»¶ä»¥æ›´æ–°ç›¸å…³çŠ¶æ€
    messageInput.dispatchEvent(new Event('input', { bubbles: true }));
    
    // æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
    checkSendButtonState(); // Use checkSendButtonState as updateSendButtonState is not defined
});

async function onSocketMessage(event) {
    let data;
    try {
        data = JSON.parse(event.data);
        // heartbeat æ¶ˆæ¯å¤ªå¤šï¼Œä¸æ‰“å°è¯¦ç»†æ—¥å¿—
        if (data.type !== 'heartbeat') { 
            logDebug(`â¬‡ï¸ æ”¶åˆ° WebSocket æ•°æ®åŒ… (${data.type})`, LOG_LEVELS.INFO, data); 
        }
    } catch (parseError) {
        const rawMessageSnippet = String(event.data).substring(0, 500);
        logDebug(`âŒ æ”¶åˆ°æ ¼å¼é”™è¯¯çš„ WebSocket æ•°æ®åŒ…`, LOG_LEVELS.ERROR, {
            error: parseError.message,
            raw: rawMessageSnippet
        });
        showAppNotification("â¬‡ï¸ å®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡å™¨å‘æ¥çš„æ ¼å¼é”™è¯¯æ¶ˆæ¯ï¼Œè¯·åˆ·æ–°é¡µé¢ã€‚", 5000, true); 
        return;
    }

    const handler = messageHandlers[data.type];
    if (handler) {
        handler(data.payload);
    } else {
        logDebug(`â¬‡ï¸ æ”¶åˆ°æœªçŸ¥ WebSocket æ¶ˆæ¯ç±»å‹: ${data.type}`, LOG_LEVELS.WARNING, data);
    }
}


 function onSocketClose(event) {
    isConnecting = false;
    statusEl.textContent = "è¿æ¥å·²æ–­å¼€";
    connectionDot.classList.add('disconnected');
    
    // ã€å…³é”®ä¿®æ”¹ã€‘åˆ¤æ–­å…³é—­ä»£ç 
    // 1008 (ç­–ç•¥è¿è§„) å’Œ 1011 (æœåŠ¡å™¨å†…éƒ¨é”™è¯¯) é€šå¸¸è¡¨ç¤ºæ°¸ä¹…æ€§é”™è¯¯
    // 4000-4999 æ˜¯ WebSocket åè®®ä¸­ä¸ºåº”ç”¨ç¨‹åºä¿ç•™çš„è‡ªå®šä¹‰é”™è¯¯ä»£ç èŒƒå›´
    // æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€äº›è‡ªå·±çš„ä»£ç ï¼Œæ¯”å¦‚ 4003 (ç¦æ­¢è®¿é—®), 4004 (æœªæ‰¾åˆ°)
    // ä½†è¿™é‡Œæˆ‘ä»¬å…ˆå¤„ç†æ ‡å‡†çš„ 1008
    const permanentErrorCodes = [1008]; 

    if (permanentErrorCodes.includes(event.code)) {
        // è¿™æ˜¯æœåŠ¡å™¨çš„æ˜ç¡®æ‹’ç»ï¼Œä¸åº”è¯¥é‡è¿
        const reason = event.reason || 'æœåŠ¡å™¨æ‹’ç»äº†è¿æ¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ–æˆ¿é—´åã€‚';
        logDebug(`ğŸš« æœåŠ¡å™¨æ˜ç¡®æ‹’ç»è¿æ¥ï¼Œåœæ­¢é‡è¿ã€‚Code: ${event.code}, åŸå› : ${reason}`, LOG_LEVELS.ERROR);
        
        // ç»™ç”¨æˆ·ä¸€ä¸ªæŒä¹…çš„ã€æ˜ç¡®çš„é”™è¯¯æç¤º
        showAppNotification(`è¿æ¥å¤±è´¥: ${reason}`, 10000, true); // æ˜¾ç¤º10ç§’
        
        // å¯ä»¥åœ¨è¿™é‡Œç¦ç”¨å‘é€æŒ‰é’®ç­‰UIå…ƒç´ 
        sendButton.disabled = true;
        
        // ã€æœ€é‡è¦ã€‘ç›´æ¥è¿”å›ï¼Œä¸å†æ‰§è¡Œä¸‹é¢çš„é‡è¿é€»è¾‘
        return; 
    }

    // --- åŸæœ‰çš„é‡è¿é€»è¾‘åªåœ¨éæ°¸ä¹…æ€§é”™è¯¯æ—¶æ‰§è¡Œ ---
    let reason = `Code: ${event.code}, Reason: ${event.reason || 'æ— '}, Was Clean: ${event.wasClean}`;
    logDebug(`â—WebSocketè¿æ¥å·²æ–­å¼€âŒã€‚${reason}`, LOG_LEVELS.WARNING);
    showAppNotification(`è¿æ¥å·²æ–­å¼€âŒï¼Œå°è¯•é‡è¿ä¸­... (${event.reason || 'æ— '})`, 3000, true); 

    logDebug(`å°†åœ¨${reconnectInterval/1000}ç§’åé‡è¿`, LOG_LEVELS.WARNING);
    setTimeout(connectWebSocket, reconnectInterval);
    
    // åªæœ‰åœ¨éå¹²å‡€æ–­å¼€æ—¶ï¼Œæ‰å¢åŠ é€€é¿æ—¶é—´
    if (!event.wasClean) {
        reconnectInterval = Math.min(reconnectInterval * 2, maxReconnectInterval); 
    }
}

    // ã€å®Œæ•´æ›¿æ¢ã€‘onSocketError å‡½æ•°
    function onSocketError(error) {
        let errorMessage = `WebSocketå‘ç”ŸæœªçŸ¥é”™è¯¯ã€‚Type: ${error.type}`;
        logDebug(errorMessage, LOG_LEVELS.ERROR, error); // æ‰“å°å®Œæ•´çš„é”™è¯¯å¯¹è±¡ä»¥ä¾¿è°ƒè¯•
        statusEl.textContent = "â— è¿æ¥é”™è¯¯";
        showAppNotification("â— WebSocketè¿æ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚", 3000, true); 
        // onSocketError é€šå¸¸ä¼šç´§è·Ÿç€ onSocketCloseï¼Œè®© onSocketClose æ¥å¤„ç†é‡è¿å†³ç­–
        // ç¡®ä¿ socket è¢«å…³é—­ï¼Œä»è€Œè§¦å‘ onSocketClose
        if (socket && socket.readyState !== WebSocket.CLOSED) {
            socket.close(1011, "Client-side error, forcing close"); // ä½¿ç”¨ 1011 çŠ¶æ€ç è¡¨ç¤ºå¼‚å¸¸
        }
    }
// --- WebRTC ç›¸å…³å‡½æ•° (ä¿æŒä¸å˜) ---
async function initLocalMedia() {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        logDebug('ğŸ¤ éº¦å…‹é£è®¿é—®æƒé™å·²è·å–', LOG_LEVELS.SUCCESS);
        return localStream;
    }
    catch (err) {
        logDebug('â—æ— æ³•è·å–éº¦å…‹é£æƒé™: ' + err, LOG_LEVELS.ERROR);
        showAppNotification('â— æ— æ³•è·å–éº¦å…‹é£ï¼Œé€šè¯åŠŸèƒ½ä¸å¯ç”¨ã€‚è¯·æ£€æŸ¥æƒé™ã€‚', 4000, true);
        return null;
    }
}

function showCallUI(targetUsername) {
    if (document.getElementById(`call-control-${targetUsername}`)) return;
    const panel = document.createElement('div');
    panel.id = `call-control-${targetUsername}`;
    panel.className = 'call-control-panel';
    panel.innerHTML = `<span>ä¸ ${escapeHTML(targetUsername)} é€šè¯ä¸­...</span><button class="hang-up-btn" data-username="${targetUsername}">ğŸ“</button>`;
    callControlsContainer.appendChild(panel);
    panel.querySelector('.hang-up-btn').onclick = () => endCall(targetUsername);
}

function hideCallUI(targetUsername) {
    document.getElementById(`call-control-${targetUsername}`)?.remove();
    document.getElementById(`audio-${targetUsername}`)?.remove();
}

async function startCall(target) {
    if (!localStream) {
        showAppNotification('ğŸ¤æœ¬åœ°éŸ³é¢‘æœªå°±ç»ªï¼Œè¯·æ£€æŸ¥éº¦å…‹é£æƒé™ã€‚', 3000, true); 
        return;
    }
    if (peerConnections[target]) return;
    showCallUI(target);
    const pc = new RTCPeerConnection(rtcConfig);
    peerConnections[target] = pc;
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    pc.ontrack = event => playRemoteStream(target, event.streams[0]);
    pc.onicecandidate = event => { if (event.candidate) socket.send(JSON.stringify({ type: 'candidate', payload: { target, candidate: event.candidate } })); };
    pc.onconnectionstatechange = () => { if (['disconnected', 'closed', 'failed'].includes(pc.connectionState)) endCall(target); };
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.send(JSON.stringify({ type: 'offer', payload: { target, sdp: pc.localDescription } }));
}

async function handleOffer({ from, sdp }) {
    if (!localStream) return;
    if (peerConnections[from]) return;
    if (!window.confirm(`${from} æ­£åœ¨å‘¼å«æ‚¨ï¼Œæ˜¯å¦æ¥å¬ï¼Ÿ`)) return;
    showCallUI(from);
    const pc = new RTCPeerConnection(rtcConfig);
    peerConnections[from] = pc;
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    pc.ontrack = event => playRemoteStream(from, event.streams[0]);
    pc.onicecandidate = event => { if (event.candidate) socket.send(JSON.stringify({ type: 'candidate', payload: { target: from, candidate: event.candidate } })); };
    pc.onconnectionstatechange = () => { if (['disconnected', 'closed', 'failed'].includes(pc.connectionState)) endCall(from); };
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    socket.send(JSON.stringify({ type: 'answer', payload: { target: from, sdp: pc.localDescription } }));
}

async function handleAnswer({ from, sdp }) {
    const pc = peerConnections[from];
    if (!pc) return;
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
}

async function handleCandidate({ from, candidate }) {
    const pc = peerConnections[from];
    if (!pc || !candidate) return;
    await pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(e => logDebug('Add ICE candidate failed: ' + e, LOG_LEVELS.ERROR));
}

function handleCallEnd({ from }) {
    const pc = peerConnections[from];
    if (pc) { pc.close(); delete peerConnections[from]; }
    hideCallUI(from);
}

function endCall(target) {
    if (socket?.readyState === WebSocket.OPEN) socket.send(JSON.stringify({ type: 'call_end', payload: { target } }));
    handleCallEnd({ from: target });
}

function playRemoteStream(username, stream) {
    let audioEl = document.getElementById(`audio-${username}`);
    if (!audioEl) {
        audioEl = document.createElement('audio');
        audioEl.id = `audio-${username}`;
        audioEl.autoplay = true;
        audioEl.playsInline = true;
        remoteAudioContainer.appendChild(audioEl);
    }
    audioEl.srcObject = stream;
    audioEl.muted = true; 
    audioEl.play().then(() => {
        audioEl.muted = false; 
    }).catch(error => {
        logDebug(`Autoplay for ${username} failed: ${error}`, LOG_LEVELS.WARNING);
        const panel = document.getElementById(`call-control-${username}`);
        if (panel && !panel.querySelector('.unmute-notice')) {
            const unmuteNotice = document.createElement('button');
            unmuteNotice.className = 'unmute-notice';
            unmuteNotice.textContent = 'ğŸ”‡ ç‚¹æ­¤å¼€å¯å£°éŸ³';
            unmuteNotice.onclick = () => {
                audioEl.muted = false;
                audioEl.play().then(() => unmuteNotice.remove()).catch(err => showAppNotification('è¿˜æ˜¯æ— æ³•æ’­æ”¾å£°éŸ³: ' + err, 3000, true));
            };
            panel.appendChild(unmuteNotice);
        }
    });
}


// --- é¡µé¢åˆå§‹åŒ–å’Œäº‹ä»¶ç›‘å¬å™¨è®¾ç½® ---
let touchStartTime;
let touchLongPressTimer; 
let currentTouchMsgEl = null;

    // ã€å®Œæ•´æ›¿æ¢ã€‘initializeChat å‡½æ•°
    function initializeChat() {
        roomNameEl.textContent = roomName;
        document.getElementById('sidebar-room-name').textContent = roomName;
        usernameDisplayEl.textContent = username;

        // åˆå§‹åŒ–æ¸…é™¤æŒ‰é’®çŠ¶æ€
        const clearInputBtn = document.getElementById('clear-input-btn');
        if (clearInputBtn) {
            clearInputBtn.style.display = 'none';
        }

        initDebugLog(); 
       // æ·»åŠ ç²˜è´´äº‹ä»¶ç›‘å¬å™¨ï¼Œç”¨äºå¤„ç†æˆªå›¾ç²˜è´´
        document.addEventListener('paste', async (e) => {
            const clipboardItems = e.clipboardData.items; // è·å–å‰ªè´´æ¿ä¸­çš„æ•°æ®é¡¹
            for (let i = 0; i < clipboardItems.length; i++) {
                const item = clipboardItems[i];
                // æ£€æŸ¥æ•°æ®é¡¹æ˜¯å¦ä¸ºæ–‡ä»¶ç±»å‹ä¸”æ˜¯å›¾ç‰‡
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„ç²˜è´´è¡Œä¸ºï¼Œå› ä¸ºæˆ‘ä»¬å°†æ‰‹åŠ¨å¤„ç†
                    const file = item.getAsFile(); // è·å– File å¯¹è±¡

                    // æ¨¡æ‹Ÿä¸€ä¸ªæ–‡ä»¶è¾“å…¥äº‹ä»¶å¯¹è±¡ï¼Œä»¥ä¾¿ handleImageSelection å¯ä»¥ç›´æ¥å¤„ç†
                    const mockChangeEvent = {
                        target: {
                            files: [file]
                        }
                    };
                    
                    logDebug(`æ£€æµ‹åˆ°ç²˜è´´å›¾ç‰‡: ${file.name} (${formatFileSize(file.size)})`, LOG_LEVELS.INFO);
                    showAppNotification('æ£€æµ‹åˆ°ç²˜è´´å›¾ç‰‡ï¼Œæ­£åœ¨å¤„ç†...');

                    try {
                        await handleImageSelection(mockChangeEvent);
                    } catch (error) {
                        logDebug(`å¤„ç†ç²˜è´´å›¾ç‰‡å¤±è´¥: ${error.message}`, LOG_LEVELS.ERROR, error);
                        showAppNotification('ç²˜è´´å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•', 3000, true);
                    }
                    
                    return; // åªå¤„ç†ç¬¬ä¸€ä¸ªæ£€æµ‹åˆ°çš„å›¾ç‰‡æ–‡ä»¶
                }
            }
        }); 
        // è°ƒç”¨ç®€åŒ–çš„èŠå¤©æ˜¾ç¤ºåˆå§‹åŒ–
        initChatDisplay(); 
        
        initLocalMedia().catch(err => {
            logDebug('åˆå§‹åŒ–åª’ä½“å¤±è´¥: ' + err, LOG_LEVELS.WARNING);
        });
        
        connectWebSocket();
        
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                // ã€ä¿®æ”¹ã€‘åªæœ‰å½“ shouldReconnect ä¸º true ä¸”å½“å‰è¿æ¥æœªæ‰“å¼€æ—¶æ‰å°è¯•é‡è¿
                if (shouldReconnect && socket?.readyState !== WebSocket.OPEN) {
                    logDebug('ğŸš€ é¡µé¢é‡æ–°å¯è§ï¼Œå°è¯•é‡æ–°è¿æ¥WebSocket', LOG_LEVELS.INFO);
                    connectWebSocket();
                }
            }
        });
        
        // ã€ä¿®æ”¹ã€‘å®šæœŸæ£€æŸ¥é‡è¿çš„ setInterval
        setInterval(() => {
            // åªæœ‰å½“ shouldReconnect ä¸º true ä¸”å½“å‰è¿æ¥æœªæ‰“å¼€æ—¶æ‰å°è¯•é‡è¿
            if (shouldReconnect && socket?.readyState !== WebSocket.OPEN) {
                logDebug('ğŸš€ æ£€æµ‹åˆ°WebSocketè¿æ¥å·²æ–­å¼€ï¼Œå°è¯•é‡æ–°è¿æ¥', LOG_LEVELS.WARNING);
                connectWebSocket();
            }
        }, 30000); 

        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            overlay.classList.toggle('show');
        });
        overlay.addEventListener('click', () => {
            sidebar.classList.remove('open');
            overlay.classList.remove('show');
        });
        onlineDisplay.addEventListener('click', (e) => {
            e.stopPropagation();
            usersMenu.classList.toggle('show');
        });

        usernameDisplayEl.addEventListener('click', () => {
            const newUsername = prompt("è¯·è¾“å…¥æ–°çš„ç”¨æˆ·å:", username);
            if (newUsername && newUsername.trim() && newUsername !== username) {
                username = newUsername.trim();
                localStorage.setItem('chat_username', username);
                usernameDisplayEl.textContent = username;
                if (socket && socket.readyState === WebSocket.OPEN) {
                    // ã€å…³é”®ä¿®æ”¹ã€‘ä¿®æ”¹ç”¨æˆ·ååï¼Œé‡ç½® shouldReconnect æ ‡å¿—ï¼Œå…è®¸ä¸€æ¬¡æ–°çš„è¿æ¥å°è¯•
                    logDebug(`ç”¨æˆ·åå·²æ›´æ–°ä¸º: ${username}ï¼Œæ­£åœ¨é‡æ–°è¿æ¥ä»¥åº”ç”¨æ›´æ”¹`, LOG_LEVELS.INFO);
                    shouldReconnect = true; 
                    socket.close(); // å…³é—­å½“å‰è¿æ¥ï¼Œè§¦å‘é‡è¿
                } else if (!socket || socket.readyState === WebSocket.CLOSED) {
                    // å¦‚æœå½“å‰æ²¡æœ‰è¿æ¥ï¼Œæˆ–è€…å·²ç»å…³é—­ï¼Œåˆ™ç›´æ¥è¿æ¥
                    logDebug(`ç”¨æˆ·åå·²æ›´æ–°ä¸º: ${username}ï¼Œæ­£åœ¨å°è¯•å»ºç«‹æ–°è¿æ¥`, LOG_LEVELS.INFO);
                    shouldReconnect = true; // ç¡®ä¿å…è®¸è¿æ¥
                    connectWebSocket();
                }
            }
        });

        attachmentBtn.addEventListener('click', () => imageInput.click());
        imageInput.addEventListener('change', handleImageSelection);
        previewRemove.addEventListener('click', removeImagePreview);
        modalClose.addEventListener('click', () => imageModal.classList.remove('show'));
        imageModal.addEventListener('click', (e) => {
            if (e.target === imageModal) imageModal.classList.remove('show');
        });
        recordButton.addEventListener('click', handleRecordButtonClick);

        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = `${Math.min(this.scrollHeight, 100)}px`;
            checkSendButtonState();
        });

        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                messageForm.dispatchEvent(new Event('submit'));
            } else if (modelSelector.style.display === 'block') {
                const options = modelSelector.querySelectorAll('.model-option');
                const activeOption = modelSelector.querySelector('.model-option:hover') || 
                                   modelSelector.querySelector('.model-option.active');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (!activeOption) {
                        options[0].classList.add('active');
                    } else {
                        activeOption.classList.remove('active');
                        const nextIndex = (Array.from(options).indexOf(activeOption) + 1) % options.length;
                        options[nextIndex].classList.add('active');
                    }
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (!activeOption) {
                        options[options.length - 1].classList.add('active');
                    } else {
                        activeOption.classList.remove('active');
                        const prevIndex = (Array.from(options).indexOf(activeOption) - 1 + options.length) % options.length;
                        options[prevIndex].classList.add('active');
                    }
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (activeOption) {
                        activeOption.click();
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    modelSelector.style.display = 'none';
                    // éšè—æ—¶è¿”å›åˆ°bodyï¼Œé¿å…å½±å“å…¶ä»–å®šä½
                    if (modelSelector.parentElement !== document.body) {
                        document.body.appendChild(modelSelector);
                    }
                }
            }
        });

        // ä¿®æ”¹è¿™é‡Œï¼Œç›´æ¥ç›‘å¬èŠå¤©çª—å£ï¼Œç„¶åæ ¹æ®ç‚¹å‡»ç›®æ ‡åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
        chatWindowEl.addEventListener('contextmenu', e => {
            const msgEl = e.target.closest('.message'); 
            if (msgEl) {
                e.preventDefault(); 
                // ä» allMessages æ•°ç»„ä¸­æ‰¾åˆ°å¯¹åº”çš„å®Œæ•´æ¶ˆæ¯æ•°æ®
                const msgData = allMessages.find(m => m.id === msgEl.dataset.id);
                if (msgData) {
                    showContextMenu(msgEl, msgData, e.pageX, e.pageY);
                } else {
                    logDebug('â— æœªæ‰¾åˆ°å¯¹åº”çš„æ¶ˆæ¯æ•°æ®ï¼Œæ— æ³•æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•ã€‚', LOG_LEVELS.WARNING, { messageId: msgEl.dataset.id });
                    if (contextMenu) contextMenu.style.display = 'none';
                }
            } else if (contextMenu) {
                contextMenu.style.display = 'none';
            }
        });

        chatWindowEl.addEventListener('touchstart', e => {
            const msgEl = e.target.closest('.message');
            if (msgEl) {
                currentTouchMsgEl = msgEl; 
                touchStartTime = Date.now(); 

                touchLongPressTimer = setTimeout(() => {
                    if (currentTouchMsgEl === msgEl && (Date.now() - touchStartTime) >= 500) {
                        e.preventDefault(); // é˜»æ­¢é»˜è®¤é•¿æŒ‰è¡Œä¸º
                        const msgData = allMessages.find(m => m.id === msgEl.dataset.id);
                        if (msgData) {
                            showContextMenu(msgEl, msgData, e.touches[0].pageX, e.touches[0].pageY);
                            if (navigator.vibrate) navigator.vibrate(50); 
                        } else {
                            logDebug('â— è§¦æ§æœªæ‰¾åˆ°å¯¹åº”çš„æ¶ˆæ¯æ•°æ®ï¼Œæ— æ³•æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•ã€‚', LOG_LEVELS.WARNING, { messageId: msgEl.dataset.id });
                            if (contextMenu) contextMenu.style.display = 'none';
                        }
                    }
                }, 500); 
            } else if (contextMenu) {
                contextMenu.style.display = 'none';
            }
        }, { passive: true }); 

        chatWindowEl.addEventListener('touchend', () => {
            clearTimeout(touchLongPressTimer); 
            currentTouchMsgEl = null; 
           //currentMessageData = null; // åœ¨æ¯æ¬¡è§¦æ§ç»“æŸæ—¶æ¸…é™¤æ•°æ®

        });

        chatWindowEl.addEventListener('touchmove', () => {
            clearTimeout(touchLongPressTimer); 
            currentTouchMsgEl = null; 
            //currentMessageData = null; // åœ¨æ¯æ¬¡è§¦æ§ç§»åŠ¨æ—¶æ¸…é™¤æ•°æ®
        }, { passive: true }); 

        document.addEventListener('click', (e) => {
            if (!usersMenu.contains(e.target) && contextMenu && !contextMenu.contains(e.target)) {
                usersMenu.classList.remove('show');
                contextMenu.style.display = 'none';
            }
        });
        
        window.showImageModal = function(imageUrl) {
            if (!imageModal || !modalImage) return;
            modalImage.src = imageUrl;
            imageModal.classList.add('show');
        };
        
        themeToggleBtn.addEventListener('click', toggleTheme);
        voiceInputButton.addEventListener('click', handleVoiceInput);
    }

    // è¯­éŸ³è¾“å…¥åŠŸèƒ½
    async function handleVoiceInput() {
        try {
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showAppNotification('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½', 3000, true);
                return;
            }

            // æ£€æŸ¥éº¦å…‹é£æƒé™
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
            } catch (err) {
                showAppNotification('éœ€è¦éº¦å…‹é£æƒé™æ‰èƒ½ä½¿ç”¨è¯­éŸ³è¾“å…¥', 3000, true);
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.lang = 'zh-CN';
            recognition.continuous = false;
            recognition.interimResults = false;

            voiceInputButton.classList.add('recording');
            voiceInputStatus.textContent = 'æ­£åœ¨è†å¬... å¯ç”¨æŒ‡ä»¤ï¼šå‘é€ã€æŸ¥è¯¢ã€æ¨¡å‹ä¸€å›ç­”ã€æ¨¡å‹äºŒå›ç­”ã€æ¨¡å‹ä¸‰å›ç­”';
            
            // æ·»åŠ ä½¿ç”¨æç¤º
            setTimeout(() => {
                if (voiceInputStatus.classList.contains('show')) {
                    voiceInputStatus.textContent = 'å¯ç”¨æŒ‡ä»¤ï¼šå‘é€ã€æŸ¥è¯¢ã€æ¨¡å‹ä¸€å›ç­”ã€æ¨¡å‹äºŒå›ç­”ã€æ¨¡å‹ä¸‰å›ç­”';
                }
            }, 2000);
            voiceInputStatus.classList.add('show');
            
            recognition.onstart = () => {
                logDebug('ğŸ¤ è¯­éŸ³è¯†åˆ«å·²å¯åŠ¨', LOG_LEVELS.INFO);
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                logDebug(`ğŸ¤ è¯­éŸ³è¯†åˆ«ç»“æœ: ${transcript}`, LOG_LEVELS.INFO);
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«æŒ‡ä»¤
                const text = transcript.trim();
                
                // å¦‚æœç›´æ¥è¯´"å‘é€"ï¼Œä¸”è¾“å…¥æ¡†æœ‰å†…å®¹
                if (text === 'å‘é€' && messageInput.value.trim()) {
                    sendMessageToBot(messageInput.value.trim());
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    checkSendButtonState();
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«AIæŒ‡ä»¤
                let aiModel = null;
                let cleanText = text;
                
                if (text.includes('æ¨¡å‹ä¸‰å›ç­”')) {
                    aiModel = 'kimi';
                    cleanText = text.replace(/æ¨¡å‹ä¸‰å›ç­”/g, '').trim();
                } else if (text.includes('æ¨¡å‹äºŒå›ç­”')) {
                    aiModel = 'deepseek';
                    cleanText = text.replace(/æ¨¡å‹äºŒå›ç­”/g, '').trim();
                } else if (text.includes('æ¨¡å‹ä¸€å›ç­”')) {
                    aiModel = 'gemini';
                    cleanText = text.replace(/æ¨¡å‹ä¸€å›ç­”/g, '').trim();
                } else if (text.includes('æŸ¥è¯¢')) {
                    aiModel = 'gemini'; // é»˜è®¤ä½¿ç”¨gemini
                    cleanText = text.replace(/æŸ¥è¯¢/g, '').trim();
                } else if (text.includes('å‘é€')) {
                    // å¤„ç†"å†…å®¹ å‘é€"çš„æƒ…å†µ
                    cleanText = text.replace(/å‘é€/g, '').trim();
                    if (cleanText) {
                        sendMessageToBot(cleanText);
                        messageInput.value = '';
                        messageInput.style.height = 'auto';
                        checkSendButtonState();
                        return;
                    }
                }
                
                // å°†æ¸…ç†åçš„æ–‡å­—æ˜¾ç¤ºåœ¨è¾“å…¥æ¡†ä¸­
                messageInput.value = cleanText;
                messageInput.style.height = 'auto';
                messageInput.dispatchEvent(new Event('input', { bubbles: true }));
                checkSendButtonState();
                
                // å¦‚æœæœ‰AIæŒ‡ä»¤ï¼Œç›´æ¥å‘é€
                if (aiModel && cleanText) {
                    sendMessageToBotWithModel(cleanText, aiModel);
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    checkSendButtonState();
                }
            };

            recognition.onerror = (event) => {
                logDebug(`ğŸ¤ è¯­éŸ³è¯†åˆ«é”™è¯¯: ${event.error}`, LOG_LEVELS.ERROR);
                let errorMessage = 'è¯­éŸ³è¯†åˆ«å¤±è´¥';
                
                switch(event.error) {
                    case 'no-speech':
                        errorMessage = 'æœªæ£€æµ‹åˆ°è¯­éŸ³';
                        break;
                    case 'audio-capture':
                        errorMessage = 'éŸ³é¢‘æ•è·å¤±è´¥';
                        break;
                    case 'not-allowed':
                        errorMessage = 'éº¦å…‹é£æƒé™è¢«æ‹’ç»';
                        break;
                }
                
                showAppNotification(errorMessage, 3000, true);
            };

            recognition.onend = () => {
                voiceInputButton.classList.remove('recording');
                setTimeout(() => {
                    voiceInputStatus.classList.remove('show');
                }, 1500);
                logDebug('ğŸ¤ è¯­éŸ³è¯†åˆ«å·²ç»“æŸ', LOG_LEVELS.INFO);
            };

            recognition.start();
            
        } catch (error) {
            logDebug(`ğŸ¤ è¯­éŸ³è¾“å…¥åŠŸèƒ½é”™è¯¯: ${error.message}`, LOG_LEVELS.ERROR);
            showAppNotification('è¯­éŸ³è¾“å…¥åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥', 3000, true);
        }
    }

    // å‘é€æ¶ˆæ¯ç»™æœºå™¨äººå¹¶å¤„ç†AIå›å¤
    async function sendMessageToBot(message) {
        try {
            logDebug(`ğŸ¤– å‘æœºå™¨äººå‘é€æ¶ˆæ¯: ${message}`, LOG_LEVELS.INFO);
            
            if (socket && socket.readyState === WebSocket.OPEN) {
                const tempId = crypto.randomUUID();
                const tempTimestamp = Date.now();
                
                socket.send(JSON.stringify({
                    type: 'gemini_chat',
                    payload: {
                        id: tempId,
                        timestamp: tempTimestamp,
                        type: 'text',
                        text: message,
                        original_user: username
                    }
                }));
                
                logDebug(`ğŸ¤– å·²å‘é€gemini_chatæ¶ˆæ¯: ${message}`, LOG_LEVELS.INFO);
                
                // AIè¯­éŸ³å›å¤ç°åœ¨ç”± processMessageQueue ç»Ÿä¸€å¤„ç†
            } else {
                showAppNotification('ç½‘ç»œè¿æ¥æœªå°±ç»ªï¼Œè¯·ç¨åå†è¯•', 3000, true);
            }
        } catch (error) {
            logDebug(`ğŸ¤– å‘é€æ¶ˆæ¯ç»™æœºå™¨äººå¤±è´¥: ${error.message}`, LOG_LEVELS.ERROR);
            showAppNotification('å‘é€æ¶ˆæ¯å¤±è´¥', 3000, true);
        }
    }

    // å‘é€æ¶ˆæ¯ç»™æŒ‡å®šAIæ¨¡å‹å¹¶å¤„ç†å›å¤
    async function sendMessageToBotWithModel(message, model) {
        try {
            logDebug(`ğŸ¤– å‘${model}å‘é€æ¶ˆæ¯: ${message}`, LOG_LEVELS.INFO);
            
            if (socket && socket.readyState === WebSocket.OPEN) {
                const tempId = crypto.randomUUID();
                const tempTimestamp = Date.now();
                
                let messageType = 'gemini_chat';
                if (model === 'kimi') {
                    messageType = 'kimi_chat';
                } else if (model === 'deepseek') {
                    messageType = 'deepseek_chat';
                } else if (model === 'gemini') {
                    messageType = 'gemini_chat';
                }
                
                socket.send(JSON.stringify({
                    type: messageType,
                    payload: {
                        id: tempId,
                        timestamp: tempTimestamp,
                        type: 'text',
                        text: message,
                        original_user: username,
                        model: model
                    }
                }));
                
                logDebug(`ğŸ¤– å·²å‘é€${messageType}æ¶ˆæ¯: ${message}`, LOG_LEVELS.INFO);
                
                // AIè¯­éŸ³å›å¤ç°åœ¨ç”± processMessageQueue ç»Ÿä¸€å¤„ç†
            } else {
                showAppNotification('ç½‘ç»œè¿æ¥æœªå°±ç»ªï¼Œè¯·ç¨åå†è¯•', 3000, true);
            }
        } catch (error) {
            logDebug(`ğŸ¤– å‘é€æ¶ˆæ¯ç»™${model}å¤±è´¥: ${error.message}`, LOG_LEVELS.ERROR);
            showAppNotification('å‘é€æ¶ˆæ¯å¤±è´¥', 3000, true);
        }
    }

    // æ–‡å­—è½¬è¯­éŸ³åŠŸèƒ½    //test
    function speakText(text) {
        try {
            if (!('speechSynthesis' in window)) {
                logDebug('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆåŠŸèƒ½', LOG_LEVELS.WARNING);
                return;
            }

            // åœæ­¢ä¹‹å‰çš„è¯­éŸ³
            window.speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'zh-CN';
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            
            utterance.onstart = () => {
                logDebug(`ğŸ”Š å¼€å§‹æ’­æ”¾è¯­éŸ³: ${text.substring(0, 50)}...`, LOG_LEVELS.INFO);
            };
            
            utterance.onend = () => {
                logDebug('ğŸ”Š è¯­éŸ³æ’­æ”¾ç»“æŸ', LOG_LEVELS.INFO);
            };
            
            utterance.onerror = (event) => {
                logDebug(`ğŸ”Š è¯­éŸ³æ’­æ”¾é”™è¯¯: ${event.error}`, LOG_LEVELS.ERROR);
            };
            
            window.speechSynthesis.speak(utterance);
            
        } catch (error) {
            logDebug(`ğŸ”Š æ–‡å­—è½¬è¯­éŸ³å¤±è´¥: ${error.message}`, LOG_LEVELS.ERROR);
        }
    }

document.addEventListener('DOMContentLoaded', initializeChat);


</script>
</body>
</html>
